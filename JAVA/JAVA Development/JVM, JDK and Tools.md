JVM, JRE, JDK
Типы памяти JVM
JIT, JIT-компиляция (Just in Time)

Разные виды JVM
AOT
Процесс компиляции в байт-код
client-jvm vs. server-jvm

## JVM
Виртуальная машина Java — это сердце экосистемы Java-технологий. Она делает для Java-программ возможность реализации принципа «написано один раз, работает везде» (write once run everywhere). Как и другие виртуальные машины, JVM представляет собой абстрактный компьютер. Основная задача JVM — загружать [class-файлы](https://en.wikipedia.org/wiki/Java_class_file) и выполнять содержащийся в них [байт-код](https://en.wikipedia.org/wiki/Java_bytecode).  
  
В состав JVM входят различные компоненты, такие как [загрузчик классов (Classloader)](https://javarevisited.blogspot.com/2012/12/how-classloader-works-in-java.html#axzz5Y4KhSOWu), [сборщик мусора (Garbage Collector)](https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html#axzz4zt6jlTWS) (автоматическое управление памятью), интерпретатор, [JIT](http://javarevisited.blogspot.sg/2011/12/jre-jvm-jdk-jit-in-java-programming.html)-компилятор, компоненты управления потоками. В этой статье рассмотрим загрузчик классов (Class loader).  
  
Загрузчик классов загружает class-файлы как для вашего приложения, так и для Java API. В виртуальную машину загружаются только те class-файлы Java API, которые действительно требуются при выполнении программы.  
  
Байт-код выполняется подсистемой исполнения (execution engine).  
  
![](https://habrastorage.org/r/w1560/webt/eu/ju/xj/eujuxjvw92kl2ul2uoydeyioici.jpeg)  
  

### Что такое загрузка классов?

  
[Загрузка классов](http://javarevisited.blogspot.sg/2012/07/when-class-loading-initialization-java-example.html#axzz4uMIMWleJ) — это поиск и загрузка типов (классов и интерфейсов) динамически во время выполнения программы. Данные о типах находятся в бинарных class-файлах.  
  

### Этапы загрузки классов

  
Подсистема загрузчика классов отвечает не только за поиск и импорт бинарных данных класса. Она также выполняет проверку правильности импортируемых классов, выделяет и инициализирует память для переменных класса, помогает в разрешении символьных ссылок. Эти действия выполняются в следующем порядке:  
  

-   **Загрузка (loading)** — поиск и импорт бинарных данных для типа по его имени, создание класса или интерфейса из этого бинарного представления.
-   **Связывание, линковка (linking)** — выполнение верификации, подготовки и, необязательного, разрешения:  
    -   **Верификация (verification)** — проверка корректности импортируемого типа.
    -   **Подготовка (preparation)** — выделение памяти для статических переменных класса и инициализация памяти значениями по умолчанию.
    -   **Разрешение (resolution)** — преобразование символьных ссылок типов в прямые ссылки.
-   **Инициализация (initialization)** — вызов Java-кода, который инициализирует переменные класса их правильными начальными значениями.

  

> Примечание — загрузчик классов, помимо загрузки классов, также отвечает за поиск ресурсов. Ресурс — это некоторые данные (например, “.class” файл, данные конфигурации, изображения), которые идентифицируются с помощью абстрактного пути, разделенного символом «/». Ресурсы обычно упаковываются вместе с приложением или библиотекой для того, чтобы их можно было использовать в коде приложения или библиотеки.

### Механизм загрузки классов в Java

  
_Примечание переводчика — в данном разделе описано поведение для java < 9, в java 9+ произошли небольшие изменения, которые описаны ниже._  
  
В Java используется модель делегирования загрузки классов. Основная идея состоит в том, что у каждого загрузчика классов есть “родительский” загрузчик. Когда происходит [загрузка класса](http://javarevisited.blogspot.sg/2012/07/when-class-loading-initialization-java-example.html#axzz4uMIMWleJ), то загрузчик “делегирует” поиск класса своему родителю, перед тем как искать класс самостоятельно.  
  
Модель делегирования загрузчиков классов представляет собой граф загрузчиков, которые передают друг другу запросы на загрузку. Корнем в этом графе является bootstrap-загрузчик. Загрузчики классов создаются с одним родителем, которому они могут делегировать загрузку, и осуществляют поиск класса в следующих местах:  
  

-   Кэш
-   Родитель
-   Сам загрузчик

  
Загрузчик классов сначала проверяет, не загружал ли он данный класс ранее. Если это так, то возвращается тот же класс, который возвращался в прошлый раз (класс, хранящийся в кэше). Если нет, то возможность загрузить класс предоставляется родителю. Эти два шага повторяются рекурсивно в глубину. Если родитель возвращает null (или бросает исключение [ClassNotFoundException](https://javarevisited.blogspot.com/2013/01/spring-javalangclassnotfoundexception-springframeworkwebcontextloaderlistener.html)), тогда загрузчик ищет класс самостоятельно.  
  
Класс загружается тем загрузчиком, который ближе всего к корню, поскольку право первому загрузить класс всегда предоставляется загрузчику-родителю. Это позволяет загрузчику видеть только классы, загруженные самостоятельно, его родителем или предками. Он не может видеть классы, загруженные дочерними загрузчиками.  
  
В Java SE Platform API исторически было определено два загрузчика классов:  
  
**Bootstrap class loader (базовый, первичный загрузчик)** — загружает классы из bootstrap classpath.  
  
**System class loader (системный загрузчик)** — родительский класс для новых загрузчиков классов и, как правило, загрузчик классов, используемый для загрузки и запуска приложения.  
  

### Загрузчики классов JDK 9+

  
**Application class loader** — обычно используется для загрузки классов приложения из classpath. Также это загрузчик по умолчанию для некоторых модулей JDK, которые содержат утилиты или экспортируют API утилит. (_Примечание переводчика: например, `jdk.jconsole`, `jdk.jshell` и др_)  
  
**Platform class loader** — загружает выбранные (на основе безопасности / разрешений) модули Java SE и JDK. Например, java.sql.  
  
**Bootstrap class loader** — загружает основные модули Java SE и JDK.  
  
Эти три встроенных загрузчика классов работают вместе следующим образом:  
  

-   _Application class loader_ сначала ищет именованные модули, определенные для всех встроенных загрузчиков. Если для одного из этих загрузчиков определен подходящий модуль, то этот загрузчик загружает класс. Если в именованном модуле, определенном для одного из этих загрузчиков, класс не найден, тогда application class loader делегирует его родителю. Если класс не найден родителем, то application class loader ищет его в classpath. Классы, найденные в classpath, загружаются как члены безымянного модуля этого загрузчика.
-   _Platform class loader_ выполняет поиск именованных модулей, определенных для всех встроенных загрузчиков. Если подходящий модуль определен для одного из этих загрузчиков, тогда этот загрузчик загружает класс. Если в именованном модуле, определенном для одного из этих загрузчиков, класс не найден, тогда platform class loader делегирует его родителю.
-   _Bootstrap class loader_ выполняет поиск именованных модулей, определенных для него самого. Если класс не найден в именованном модуле, определенном для bootstrap-загрузчика, тогда bootstrap-загрузчик ищет файлы и каталоги, добавленные в bootstrap classpath, с помощью параметра -Xbootclasspath/a (позволяет добавить файлы и каталоги к bootstrap classpath). Классы, найденные в bootstrap classpath, загружаются как члены безымянного модуля этого загрузчика.

### Byte-code
Как мы уже знаем, весь исходный код, написанный на языке программирования Java, сначала компилируется в [байт-код](https://en.wikipedia.org/wiki/Java_bytecode) с помощью компилятора `javac`, входящего в состав Java Development Kit. Байт-код сохраняется в бинарный файл в специальный class-файл. Затем эти class-файлы динамически (при необходимости) загружаются в память загрузчиком классов (ClassLoader).  
  
![](https://habrastorage.org/r/w1560/webt/cq/p9/ti/cqp9tijwjcgoydxnlrtrlqb-5au.jpeg)  
_Рисунок — компиляция исходного кода Java_  
  
Каждый файл с расширением `.java` компилируется как минимум в один файл `.class`. Для каждого класса, интерфейса и модуля, определенных в исходном коде, создается по одному `.class` файлу. Это также относится к интерфейсам и вложенным классам.  
  
Примечание — для простоты файлы с расширением `.class` будем называть “class-файлами”.  
  
Давайте напишем простую программу.  
  

```java
public class ClassOne{
    public static void main(String[] args){
        System.out.println("Hello world");
    }
    static class StaticNestedClass{
    }
}

class ClassTwo{
}

interface InterfaceOne{
}
```

  
Запуск `javac` для этого файла приведет к появлению следующих файлов.  
  

```
ClassOne$StaticNestedClass.class
ClassOne.class
ClassTwo.class
InterfaceOne.class
```

  
Как видите, для каждого класса и интерфейса создается отдельный class-файл.  
  

### Что внутри class-файла?

  
Class-файл имеет бинарный формат. Информация в нем обычно записывается без отступов между последовательными частями информации, все выравнивается по границам байтов. Все 16-битные и 32-битные значения записываются с помощью двух или четырех последовательных 8-битных байтов.  
  
Class-файл содержит следующую информацию.  
  
**Магическое число, сигнатура**. Первые четыре байта каждого class-файла всегда `0xCAFEBABE`. Эти четыре байта идентифицируют class-файл Java.  
  
**Версия файла.** Следующие четыре байта содержат мажорную и минорную версию файла. Вместе эти номера определяют версию формата class-файла. Если class-файл имеет основной мажорную версию M и минорную m, то мы обозначаем эту версию как M.m.  
  
У каждой JVM есть ограничения по поддерживаемым версиям class-файлов. Например, Java 11 поддерживает major версию с 45 до 55, Java 12 — с 45 по 56.  
  
**Пул констант.** Таблица структур, представляющих строковые константы, имена классов, интерфейсов, полей, методов и другие константы, которые есть в структуре ClassFile и ее подструктурах. Каждый элемент пула констант начинается с однобайтового тега, определяющего тип константы. В зависимости от типа константы следующие байты могут быть непосредственным значением константы или ссылкой на другой элемент в пуле.  
  
**Флаги доступа.** Список флагов, которые указывают класс это или интерфейс, public или private, финальный класс или нет. Различные флаги, такие как `ACC_PUBLIC`, `ACC_FINAL`, `ACC_INTERFACE`, `ACC_ENUM` и т. д. описаны спецификации Java Virtual Machine Specification.  
  
**This class.** Ссылка на запись в пуле констант.  
  
**Super class.** Ссылка на запись в пуле констант.  
  
**Интерфейсы.** Количество интерфейсов, реализованных классом.  
  
**Количество полей.** Количество полей в классе или интерфейсе.  
  
**Поля.** После количества полей следует таблица структур переменной длины. По одной для каждого поля с описанием типа поля и названия (со ссылкой на пул констант).  
  
**Количество методов.** Количество методов в классе или интерфейсе. Это число включает только методы, которые явно определены в классе, без методов, унаследованных от суперклассов.  
  
**Методы.** Далее находятся сами методы. Для каждого метода содержится следующая информация: дескриптор метода (тип возвращаемого значения и список аргументов), количество слов, необходимых для локальных переменных метода, максимальное количество слов стека, необходимых для стека операндов метода, таблицу исключений, перехватываемых методом, байт-коды метода и таблица номеров строк.  
  
**Количество атрибутов.** Количество атрибутов в этом классе, интерфейсе или модуле.  
  
**Атрибуты.** После количества атрибутов следуют таблицы или структуры переменной длины, описывающие каждый атрибут. Например, всегда есть атрибут “SourceFile”. Он содержит имя исходного файла, из которого был скомпилирован class-файл.  
  
Хотя class-файл напрямую не человекочитаемый, в JDK есть инструмент под названием **javap**, который выводит его содержимое в удобном формате.  
  
Давайте напишем простую программу на Java, указанную ниже.  
  

```java
package bytecode;
import java.io.Serializable;

public class HelloWorld implements Serializable, Cloneable {

    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

  
Давайте скомпилируем эту программу с помощью `javac`, которая создаст файл `HelloWorld.class`, и используем `javap` для просмотра файла `HelloWorld.class`. Запустив `javap` с параметром `-v (verbose)` для `HelloWorld.class` получим следующий результат:  
  

```
Classfile /Users/apersiankite/Documents/code_practice/java_practice/target/classes/bytecode/HelloWorld.class
  Last modified 02-Jul-2019; size 606 bytes
  MD5 checksum 6442d93b955c2e249619a1bade6d5b98
  Compiled from "HelloWorld.java"
public class bytecode.HelloWorld implements java.io.Serializable,java.lang.Cloneable
  minor version: 0
  major version: 55
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #5                          // bytecode/HelloWorld
  super_class: #6                         // java/lang/Object
  interfaces: 2, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #6.#22         // java/lang/Object."<init>":()V
   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #25            // Hello World
   #4 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #28            // bytecode/HelloWorld
   #6 = Class              #29            // java/lang/Object
   #7 = Class              #30            // java/io/Serializable
   #8 = Class              #31            // java/lang/Cloneable
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               Lbytecode/HelloWorld;
  #16 = Utf8               main
  #17 = Utf8               ([Ljava/lang/String;)V
  #18 = Utf8               args
  #19 = Utf8               [Ljava/lang/String;
  #20 = Utf8               SourceFile
  #21 = Utf8               HelloWorld.java
  #22 = NameAndType        #9:#10         // "<init>":()V
  #23 = Class              #32            // java/lang/System
  #24 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;
  #25 = Utf8               Hello World
  #26 = Class              #35            // java/io/PrintStream
  #27 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V
  #28 = Utf8               bytecode/HelloWorld
  #29 = Utf8               java/lang/Object
  #30 = Utf8               java/io/Serializable
  #31 = Utf8               java/lang/Cloneable
  #32 = Utf8               java/lang/System
  #33 = Utf8               out
  #34 = Utf8               Ljava/io/PrintStream;
  #35 = Utf8               java/io/PrintStream
  #36 = Utf8               println
  #37 = Utf8               (Ljava/lang/String;)V
{
  public bytecode.HelloWorld();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lbytecode/HelloWorld;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello World
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 7: 0
        line 8: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
}
SourceFile: "HelloWorld.java"
```

  
Здесь вы можете увидеть, что класс публичный (`public`) и у него в пуле констант 37 записей. Есть один атрибут (SourceFile внизу), класс реализует два интерфейса (Serializable, Cloneable), у него нет полей и есть два метода.  
  
Возможно, вы заметили, что в исходном коде есть только один статический метод main, но class-файл говорит, что есть два метода. Вспомните конструктор по умолчанию — это конструктор без аргументов, добавленный компилятором `javac`, байт-код которого также виден в выводе. Конструкторы рассматриваются как методы.

## JVM, JRE, JDK
![](https://habrastorage.org/r/w1560/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png)  
  

### 1. JDK, JRE, JVM

  
[Java Development Kit](https://docs.oracle.com/en/java/javase/13/docs/specs/man/index.html) — комплект разработчика приложений на языке Java. Он включает в себя [Java Development Tools](https://docs.oracle.com/javase/6/docs/technotes/tools/index.html) и среду выполнения Java — [JRE](https://www.oracle.com/technetwork/java/javase/jre-8-readme-2095710.html) (Java Runtime Environment).  
  
**Java development tools** включают в себя около 40 различных тулов: javac (компилятор), java (лаунчер для приложений), javap (java class file disassembler), jdb (java debugger) и др.  
  
Среда выполнения JRE — это пакет всего необходимого для запуска скомпилированной Java-программы. Включает в себя виртуальную машину [JVM](https://docs.oracle.com/javase/6/docs/technotes/guides/vm/index.html) и библиотеку классов Java — **Java Class Library**.  
  
**JVM** — это программа, предназначенная для выполнения байт-кода. Первое преимущество JVM — это принцип _“Write once, run anywhere”_. Он означает, что приложение, написанное на Java, будет работать одинаково на всех платформах. Это является большим преимуществом JVM и самой Java.  
  
До появления Java, многие компьютерные программы были написаны под определенные компьютерные системы, а предпочтение отдавалось ручному управлению памятью, как более эффективному и предсказуемому. Со второй половины 1990-х годов, после появления Java, автоматическое управление памятью стало общей практикой.  
  
Существует множество реализаций JVM, как коммерческих, так и с открытым кодом. Одна из целей создания новых JVM — увеличение производительности для конкретной платформы. Каждая JVM пишется под платформу отдельно, при этом есть возможность написать ее так, чтобы она работала быстрее на конкретной платформе. Самая распространённая реализация JVM — это JVM Hotspot от [OpenJDK](https://openjdk.java.net/). Также есть реализации [IBM J9](https://www.ibm.com/support/knowledgecenter/SS4QMC_9.3.0/com.ibm.help.perf.manage.doc/c_FND_PM_IBMJ9JVM.html), [Excelsior JET](https://en.wikipedia.org/wiki/Excelsior_JET).  
  

### 2. Выполнение кода на JVM

  
Согласно [спецификации Java SE](https://docs.oracle.com/javase/specs/), для того, чтобы получить код, работающий в JVM, необходимо выполнить 3 этапа:  
  

-   Загрузка байт-кода и создание экземпляра класса Class  
    Грубо говоря, чтобы попасть на JVM, класс должен быть загружен. Для этого существуют отдельные класс-загрузчики, к ним мы вернемся чуть позже.
-   Связывание или линковка  
    После загрузки класса начинается процесс линковки, на котором байт-код разбирается и проверяется. Процесс линковки в свою очередь происходит в 3 шага:  
      
    — verification или проверка байт-кода: проверяется корректность инструкций, возможность переполнения стека на данном участке кода, совместимость типов переменных; проверка происходит один раз для каждого класса;  
    — preparation или подготовка: на данном этапе в соответствии со спецификацией выделяется память под статические поля и происходит их инициализация;  
    — resolution или разрешение: разрешение символьных ссылок (когда в байт-коде мы открываем файлы с расширением .class, мы видим числовые значения вместо символьных ссылок).
-   Инициализация полученного объекта Class  
    На последнем этапе класс, который мы создали, инициализируется, и JVM может начинать его исполнение.

  

### 3. Загрузчики классов и их иерархия

  
Вернемся к загрузчикам классов — это специальные классы, которые являются частью JVM. Они загружают классы в память и делают их доступными для выполнения. Загрузчики работают со всеми классами: и с нашими, и с теми, которые непосредственно нужны для Java.  
  
Представьте ситуацию: мы написали свое приложение, и помимо стандартных классов там есть наши классы, и их очень много. Как с этим будет работать JVM? В Java реализована отложенная загрузка классов, иными словами lazy loading. Это значит, что загрузка классов не будет выполняться до тех пор, пока в приложении не встретится обращение к классу.  
  

#### Иерархия загрузчиков классов

  
  
![](https://habrastorage.org/r/w1560/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png)  
  
Первый загрузчик классов — это **Bootstrap classloader**. Он написан на C++. Это базовый загрузчик, который загружает все системные классы из архива _rt.jar_. При этом, есть небольшое отличие между загрузкой классов из _rt.jar_ и наших классов: когда JVM загружает классы из _rt.jar_, она не выполняет все этапы проверки, которые выполняются при загрузке любого другого класс-файла т.к. JVM изначально известно, что все эти классы уже проверены. Поэтому, включать в этот архив какие-либо свои файлы не стоит.  
  
Следующий загрузчик — это **Extension classloader.** Он загружает классы расширений из папки _jre/lib/ext_. Допустим, вы хотите, чтобы какой-то класс загружался каждый раз при старте Java машины. Для этого вы можете скопировать исходный файл класса в эту папку, и он будет автоматически загружаться.  
  
Еще один загрузчик — **System classloader**. Он загружает классы из classpath’а, который мы указали при запуске приложения.  
  
Процесс загрузки классов происходит по иерархии:  
  

-   В первую очередь мы запрашиваем поиск в кэше System Class Loader (кэш системного загрузчика содержит классы, которые уже были им загружены);
-   Если класс не был найден в кэше системного загрузчика, мы смотрим кэш Extension class loader;
-   Если класс не найден в кэше загрузчика расширений, класс запрашивается у загрузчика Bootstrap.

  
Если класс не найден в кэше Bootstrap, он пытается загрузить этот класс. Если Bootstrap не смог загрузить класс, он делегирует загрузку класса загрузчику расширений. Если на этот момент класс будет загружен, он остается в кэше у Extension classloader, а загрузка класса является завершенной.  
  

### 4. Структура Сlass-файлов и процесс загрузки

  
Перейдем непосредственно к структуре Class-файлов.  
  
Один класс, написанный на Java, компилируется в один файл с расширением .class. Если в нашем Java файле лежит несколько классов, один файл Java может быть скомпилирован в несколько файлов с расширением .class — файлов байт-кода данных классов.  
  
Все числа, строки, указатели на классы, поля и методы хранятся в _Сonstant pool_ — области памяти _Meta space_. Описание класса хранится там же и содержит имя, модификаторы, супер-класс, супер-интерфейсы, поля, методы и атрибуты. Атрибуты, в свою очередь, могут содержать любую дополнительную информацию.  
  
Таким образом, при загрузке классов:  
  

-   происходит чтение класс-файла, т.е проверка корректности формата
-   создается представление класса в Constant pool (Meta space)
-   грузятся супер-классы и супер-интерфейсы; если они не будут загружены, то и сам класс не будет загружен

  

### 5. Исполнение байт-кода на JVM

  
В первую очередь, для исполнения байт-кода, JVM может его _интерпретировать_. Интерпретация — довольно медленный процесс. В процессе интерпретации, интерпретатор “бежит” построчно по класс-файлу и переводит его в команды, которые понятны JVM.  
  
Также JVM может его _транслировать_, т.е. скомпилировать в машинный код, который будет исполняться непосредственно на CPU.  
  
Команды, которые исполняются часто, не будут интерпретироваться, а сразу будут транслироваться.  
  

### 6. Компиляция

  
**Компилятор** — это программа, которая преобразует исходные части программ, написанные на языке программирования высокого уровня, в программу на машинном языке, “понятную” компьютеру.  
  
Компиляторы делятся на:  
  

-   _Не оптимизирующие_
-   _Простые оптимизирующие_ (Hotspot Client): работают быстро, но порождают неоптимальный код
-   _Сложные оптимизирующие_ (Hotspot Server): производят сложные оптимизирующие преобразования прежде чем сформировать байт-код

  
  
Также компиляторы могут классифицироваться по моменту компиляции:  
  

-   _Динамические компиляторы_  
    Работают одновременно с программой, что сказывается на производительности. Важно, чтобы эти компиляторы работали на коде, который часто исполняется. Во время исполнения программы JVM знает, какой код выполняется чаще всего, и, чтобы постоянно не интерпретировать его, виртуальная машина сразу переводит его в команды, которые уже будут исполняться непосредственно на процессорe.
-   _Статические компиляторы_  
    Дольше компилируют, но порождают оптимальный код для исполнения. Из плюсов: не требуют ресурсов во время исполнения программы, каждый метод компилируется с применением оптимизаций.

  

### 7. Организация памяти в Java

  
**Стек** — это область памяти в Java, которая работает по схеме LIFO — “_Last in — Fisrt Out_” или “_Последним вошел, первым вышел_”.  
  
![](https://habrastorage.org/r/w1560/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png)  
  
Он нужен для того, чтобы хранить методы. Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы.  
  
Когда вызывается любой метод в Java, создается фрейм или область памяти в стеке, и метод кладется на его вершину. Когда метод завершает выполнение, он удаляется из памяти, тем самым освобождая память для следующих методов. Если память стека будет заполнена, Java бросит исключение _java.lang.StackOverFlowError_. К примеру, это может произойти, если у нас будет рекурсивная функция, которая будет вызывать сама себя и памяти в стеке не будет хватать.  
  
Ключевые особенности стека:  
  

-   Стек заполняется и освобождается по мере вызова и завершения новых методов
-   Доступ к этой области памяти осуществляется быстрее, чем к куче
-   Размер стека определяется операционной системой
-   Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

  
Ещё одна область памяти в Java — **Heap** или **куча**. Она используется для хранения объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке. Все объекты в куче имеют глобальный доступ, то есть к ним можно получить доступ из любой точки приложения.  
  
Куча разбита на несколько более мелких частей, называемых поколениями:  
  

-   _Young generation_ — область, где размещаются недавно созданные объекты
-   _Old (tenured) generation_ — область, где хранятся “долгоживущие” объекты
-   До Java 8 существовала ещё одна область — _Permanent generation_ — которая содержит метаинформацию о классах, методах, статических переменных. После появления Java 8 было решено хранить эту информацию отдельно, вне кучи, а именно в Meta space

  
  
![](https://habrastorage.org/r/w1560/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png)  
  
Почему отказались от Permanent generation? В первую очередь, это из-за ошибки, которая была связана с переполнением области: так как Perm имел константный размер и не мог расширяться динамически, рано или поздно память заканчивалась, кидалась ошибка, и приложение падало.  
  
Meta space же имеет динамический размер, и во время исполнения он может расширяться до размеров памяти JVM.  
  
Ключевые особенности кучи:  
  

-   Когда эта область памяти заполняется полностью, Java бросает _java.lang.OutOfMemoryError_
-   Доступ к куче медленнее, чем к стеку
-   Для сбора неиспользуемых объектов работает сборщик мусора
-   Куча, в отличие от стека, не является потокобезопасной, так как любой поток может получить к ней доступ

  
  
Основываясь на информации выше, рассмотрим, как происходит управление памятью на простом примере:  
  

```
public class App {
    public static void main(String[] args) {
        int id = 23;
        String pName = "Jon";
        Person p = null;
        p = new Person(id, pName);
    }
}
class Person {
    int pid;
    String name;
    
    // constructors, getters/setters
}
```

  
  
У нас есть класс App, в котором единственный метод _main_ состоит из:  
  
— примитивной переменой **id** типа **int** со значением **23**  
— ссылочной переменной **pName** типа **String** со значением **Jon**  
— ссылочной переменной **p** типа **person**  
  
![](https://habrastorage.org/r/w1560/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png)  
  
Как уже упоминалось, при вызове метода на вершине стека создаётся область памяти, в которой хранятся данные, необходимые этому методу для выполнения.  
В нашем случае, это ссылка на класс _person_: сам объект хранится в куче, а в стеке хранится ссылка. Также в стек кладется ссылка на строку, а сама строка хранится в куче в String pool. Примитив хранится непосредственно в стеке.  
  
Для вызова конструктора с параметрами _Person (String)_ из метода _main()_ в стеке, поверх предыдущего вызова _main()_ создается в стеке отдельный фрейм, который хранит:  
  
— **this** — ссылка на текущий объект  
— примитивное значение **id**  
— ссылочную переменную **personName**, которая указывает на строку в String Pool.  
  
После того, как мы вызвали конструктор, вызывается _setPersonName()_, после чего снова создается новый фрейм в стеке, где хранятся те же данные: ссылка на объект, ссылка на строку, значение переменной.  
  
Таким образом, когда выполнится метод _setter_, фрейм пропадет, стек очистится. Далее выполняется конструктор, очищается фрейм, который был создан под конструктор, после чего метод _main()_ завершает свою работу и тоже удаляется из стека.  
  
Если будут вызваны другие методы, для них будут также созданы новые фреймы с контекстом этих конкретных методов.  
  

### 8. Garbage collector

  
В куче работает [Garbage collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html) — программа, работающая на виртуальной машине Java, которая избавляется от объектов, к которым невозможно получить доступ.  
  
Разные JVM могут иметь различные алгоритмы сборки мусора, также существуют разные сборщики мусора.  
  
Мы поговорим о самом простом сборщике **Serial GC**. Сборку мусора мы запрашиваем при помощи _System.gc()_.  
  
![](https://habrastorage.org/r/w1560/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png)  
  
Как уже было упомянуто выше, куча разбита на 2 области: New generation и Old generation.  
  
New generation (младшее поколение) включает в себя 3 региона: _Eden_, _Survivor 0_ и _Survivor 1_.  
  
Old generation включает в себя регион _Tenured_.  
  
Что происходит, когда мы создаем в Java объект?  
  
В первую очередь объект попадает в _Eden_. Если мы создали уже много объектов и в _Eden_ уже нет места, срабатывает сборщик мусора и освобождает память. Это, так называемая, _малая сборка мусора_ — на первом проходе он очищает область _Eden_ и кладёт “выжившие” объекты в регион _Survivor 0_. Таким образом регион _Eden_ полностью высвобождается.  
  
Если произошло так, что область _Eden_ снова была заполнена, garbage collector начинает работу с областью _Eden_ и областью _Survivor 0_, которая занята на данный момент. После очищения выжившие объекты попадут в другой регион — _Survivor 1_, а два остальных останутся чистыми. При последующей сборке мусора в качестве региона назначения опять будет выбран _Survivor 0_. Именно поэтому важно, чтобы один из регионов _Survivor_ всегда был пустым.  
  
JVM следит за объектами, которые постоянно копируются и перемещаются из одного региона в другой. И для того, чтобы оптимизировать данный механизм, после определённого порога сборщик мусора перемещает такие объекты в регион _Tenured_.  
  
Когда в _Tenured_ места для новых объектов не хватает, происходит полная сборка мусора — **Mark-Sweep-Compact**.  
  
![](https://habrastorage.org/r/w1560/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png)  
  
Во время этого механизма определяется, какие объекты больше не используются, регион очищается от этих объектов, и область памяти _Tenured_ дефрагментируется, т.е. последовательно заполняется нужными объектами.

## Типы памяти JVM
**Два вида памяти**  
  
JVM разделяет память на две основные категории: «кучу» (heap) и «не кучу» (non-heap). Куча — это часть памяти JVM, с которой разработчики наиболее знакомы. Здесь хранятся объекты, созданные приложением. Они остаются там до тех пор, пока не будут убраны сборщиком мусора. Как правило, размер кучи, которую использует приложение, изменяется в зависимости от текущей нагрузки.  
  
Память вне кучи делится на несколько областей. В HotSpot для изучения областей этой памяти можно использовать механизм [Native memory tracking (NMT)](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html). Обратите внимание, что, хотя NMT не отслеживает использование всей нативной памяти ([например, не отслеживается выделение нативной памяти сторонним кодом](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html)), его возможностей достаточно для большинства типичных приложений на Spring. Для использования NMT запустите приложение с параметром `-XX:NativeMemoryTracking=summary` и с помощью [](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html)[jcmd VM.native_memory summary посмотрите информацию об используемой памяти.  
  
Давайте посмотрим использование NMT на примере нашего старого друга Petclinic](http://projects.spring.io/spring-petclinic/). Диаграмма ниже показывает использование памяти JVM по данным NMT (за вычетом собственного оверхеда NMT) при запуске Petclinic с максимальным размером кучи 48 МБ (`-Xmx48M`):  
  
![](https://habrastorage.org/r/w1560/webt/m8/nk/be/m8nkberjczog7bolri8lwoglbbm.png)  
  
Как вы видите, на память вне кучи приходится большая часть используемой памяти JVM, причем память кучи составляет только одну шестую часть от общего объёма. В этом случае это примерно 44 МБ (из которых 33 МБ использовалось сразу после сборки мусора). Использование памяти вне кучи составило в сумме 223 МБ.  
  
**Области нативной памяти**  
  
**Compressed class space** (область сжатых указателей): используется для хранения информации о загруженных классах. Ограничивается параметром `MaxMetaspaceSize`. Функция количества классов, которые были загружены.  
  
_Примечание переводчика_  
  

> Почему-то автор пишет про «Compressed class space», а не про всю область «Class». Область «Compressed class space» входит в состав области «Сlass», а параметр `MaxMetaspaceSize` ограничивает размер всей области «Class», а не только «Compressed class space». Для ограничения «Compressed class space» используется параметр `CompressedClassSpaceSize`.  
>   
> [Отсюда](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html#sthref66):  
> If `UseCompressedOops` is turned on and `UseCompressedClassesPointers` is used, then two logically different areas of native memory are used for class metadata…  
> A region is allocated for these compressed class pointers (the 32-bit offsets). The size of the region can be set with `CompressedClassSpaceSize` and is 1 gigabyte (GB) by default…  
> The `MaxMetaspaceSize` applies to the sum of the committed compressed class space and the space for the other class metadata  
>   
> Если включен параметр `UseCompressedOops` и используется `UseCompressedClassesPointers`, тогда для метаданных классов используется две логически разные области нативной памяти…  
>   
> Для сжатых указателей выделяется область памяти (32-битные смещения). Размер этой области может быть установлен `CompressedClassSpaceSize` и по умолчанию он 1 ГБ…  
> Параметр `MaxMetaspaceSize` относится к сумме области сжатых указателей и области для других метаданных класса.

  
  

-   Thread (потоки): память, используемая потоками в JVM. Функция количества запущенных потоков.
-   Code cache (кэш кода): память, используемая JIT для его работы. Функция количества классов, которые были загружены. Ограничивается параметром `ReservedCodeCacheSize`. Можно уменьшить настройкой JIT, например, отключив многоуровневую компиляцию (tiered compilation).
-   GC (сборщик мусора): хранит данные, используемые сборщиком мусора. Зависит от используемого сборщика мусора.
-   Symbol (символы): хранит такие символы, как имена полей, сигнатуры методов и интернированные строки. Чрезмерное использование памяти символов может указывать на то, что строки слишком интернированы.
-   Internal (внутренние данные): хранит прочие внутренние данные, которые не входят ни в одну из других областей.

  
**Отличия**  
  
По сравнению с кучей, память вне кучи меньше изменяется под нагрузкой. Как только приложение загрузит все классы, которые будут использоваться и JIT полностью прогреется, всё перейдет в устойчивое состояние. Чтобы увидеть уменьшение использования области _Compressed class space_, загрузчик классов, который загрузил классы, должен быть удален сборщиком мусора. Это было распространено в прошлом, когда приложения развертывались в контейнерах сервлетов или серверах приложений (загрузчик классов приложения удалялся сборщиком мусора, когда приложение удалялось с сервера приложений), но с современными подходами к развертыванию приложений это случается редко.  
  
**Настройка JVM**  
  
Настроить JVM для эффективного использования доступной оперативной памяти непросто. Если вы запустите JVM с параметром `-Xmx16M` и ожидаете, что будет использоваться не более 16 МБ памяти, то вас ждёт неприятный сюрприз.  
  
Интересной областью памяти JVM является кэш кода JIT. По умолчанию HotSpot JVM будет использовать до 240 МБ. Если кэш кода слишком мал, в JIT может не хватить места для хранения своих данных, и в результате будет снижена производительность. Если кэш слишком велик, то память может быть потрачена впустую. При определении размера кэша важно учитывать его влияние как на использование памяти, так и на производительность.  
  
При работе в контейнере Docker последние версии Java [теперь знают](https://bugs.openjdk.java.net/browse/JDK-8146115) об ограничениях памяти контейнера и пытаются соответствующим образом изменить размер памяти JVM. К сожалению, часто происходит выделение большого количества памяти вне кучи и недостаточного в куче. Допустим, у вас есть приложение, работающее в контейнере с 2-мя процессорами и 512 МБ доступной памяти. Вы хотите, чтобы обрабатывалось больше нагрузки и увеличиваете количество процессоров до 4-х и память до 1 ГБ. Как мы обсуждали выше, размер кучи обычно изменяется в зависимости от нагрузки, а память вне кучи изменяется значительно меньше. Поэтому мы ожидаем, что большая часть дополнительных 512 МБ будет предоставлена куче, чтобы справиться с увеличенной нагрузкой. К сожалению, по умолчанию JVM этого не сделает и распределит дополнительную память более менее равномерно между памятью в куче и вне кучи.  
  
К счастью, команда CloudFoundry обладает обширными знаниями о распределении памяти в JVM. Если вы загружаете приложения в CloudFoundry, то сборщик (build pack) автоматически применит эти знания для вас. Если вы не используете CloudFoudry или хотели бы больше понять о том, как настроить JVM, то рекомендуется прочитать [описание](https://docs.google.com/document/d/1vlXBiwRIjwiVcbvUGYMrxx2Aw1RVAtxq3iuZ3UK2vXA/edit?usp=sharing) третьей версии [Java buildpack’s memory calculator](https://github.com/cloudfoundry/java-buildpack-memory-calculator).  
  
**Что это значит для Spring**  
  
Команда Spring проводит много времени, думая о производительности и использовании памяти, рассматривая возможность использования памяти как в куче, так и вне кучи. Один из способов ограничить использование памяти вне кучи — это делать части фреймворка максимально универсальными. Примером этого является использование Reflection для создания и внедрения зависимостей в бины вашего приложения. Благодаря использованию Reflection количество кода фреймворка, который вы используете, остается постоянным, независимо от количества бинов в вашем приложении. Для оптимизации времени запуска мы используем кэш в куче, очищая этот кэш после завершения запуска. Память кучи может быть легко очищена сборщиком мусора, чтобы предоставить больше доступной памяти вашему приложению.
## JIT
JIT (Just-in-Time) компилятор оказывает огромное влияние на быстродействие приложения. Понимание принципов его работы, способов мониторинга и настройки является важным для каждого Java-программиста. В цикле статей из двух частей мы рассмотрим устройство JIT компилятора в HotSpot JVM, способы мониторинга его работы, а также возможности его настройки. В этой, первой части мы рассмотрим устройство JIT компилятора и способы мониторинга его работы.  
  

### AOT и JIT компиляторы

  
Процессоры могут исполнять только ограниченный набор инструкций — машинный код. Для исполнения программы процессором, она должна быть представлена в виде машинного кода.  
  
Существуют компилируемые языки программирования, такие как C и C++. Программы, написанные на этих языках, распространяются в виде машинного кода. После того, как программа написана, специальный процесс — Ahead-of-Time (AOT) компилятор, обычно называемый просто компилятором, транслирует исходный код в машинный. Машинный код предназначен для выполнения на определенной модели процессора. Процессоры с общей архитектурой могут выполнять один и тот же код. Более поздние модели процессора как правило поддерживают инструкции предыдущих моделей, но не наоборот. Например, машинный код, использующий AVX инструкции процессоров Intel Sandy Bridge не может выполняться на более старых процессорах Intel. Существуют различные способы решения этой проблемы, например, вынесение критичных частей программы в библиотеку, имеющую версии под основные модели процессора. Но часто программы просто компилируются для относительно старых моделей процессоров и не используют преимущества новых наборов инструкций.  
  
В противоположность компилируемым языкам программирования существуют интерпретируемые языки, такие как Perl и PHP. Один и тот же исходный код при таком подходе может быть запущен на любой платформе, для которой существует интерпретатор. Минусом этого подхода является то, что интерпретируемый код работает медленнее, чем машинный код, делающий тоже самое.  
  
Язык Java предлагает другой подход, нечто среднее между компилируемыми и интерпретируемыми языками. Приложения на языке Java компилируются в промежуточный низкоуровневый код — байт-код (bytecode).  

> Название байт-код было выбрано потому, что для кодирования каждой операции используется ровно один байт. В Java 10 существует около 200 операций.  

  
Байт-код затем исполняется JVM также как и программа на интерпретируемом языке. Но поскольку байт-код имеет строго определенный формат, JVM может компилировать его в машинный код прямо во время выполнения. Естественно, старые версии JVM не смогут сгенерировать машинный код, использующий новые наборы инструкций процессоров вышедших после них. С другой стороны, для того, чтобы ускорить Java-программу, ее даже не надо перекомпилировать. Достаточно запустить ее на более новой JVM.  
  

### HotSpot JIT компилятор

  
В различных реализациях JVM JIT компилятор может быть реализован по-разному. В данной статье мы рассматриваем Oracle HotSpot JVM и ее реализацию JIT компилятора. Название HotSpot происходит от подхода, используемого в JVM для компиляции байт-кода. Обычно в приложении только небольшие части кода выполняются достаточно часто и производительность приложения в основном зависит от скорости выполнения именно этих частей. Эти части кода называются горячими точками (hot spots), их и компилирует JIT компилятор. В основе этого подхода лежит несколько суждений. Если код будет исполнен всего один раз, то компиляция этого кода — пустая трата времени. Другая причина — это оптимизации. Чем больше раз JVM исполняет какой либо код, тем больше статистики она накапливает, используя которую можно сгенерировать более оптимизированный код. К тому же компилятор разделяет ресурсы виртуальной машины с самим приложением, поэтому ресурсы затраченные на профилирование и оптимизацию могли бы быть использованы для исполнения самого приложения, что заставляет соблюдать определенный баланс. Единицей работы для HotSpot компилятора является метод и цикл.  

> Единица скомпилированного кода называется nmethod (сокращение от native method).  

  

### Многоуровневая компиляция (tiered compilation)

  
На самом деле в HotSpot JVM существует не один, а два компилятора: C1 и C2. Другие их названия клиентский (client) и серверный (server). Исторически C1 использовался в GUI приложениях, а C2 в серверных. Отличаются компиляторы тем, как быстро они начинают компилировать код. C1 начинает компилировать код быстрее, в то время как C2 может генерировать более оптимизированный код.  
  
В ранних версиях JVM приходилось выбирать компилятор, используя флаги **-client** для клиентского и **-server** или **-d64** для серверного. В JDK 6 был внедрен режим многоуровневой компиляции. Грубо говоря, его суть заключается в последовательном переходе от интерпретируемого кода к коду, сгенерированному компилятором C1, а затем C2. В JDK 8 флаги -client, -server и -d64 игнорируются, а в JDK 11 флаг -d64 был удален и приводит к ошибке. Выключить режим многоуровневой компиляции можно флагом **-XX:-TieredCompilation**.  
  
Существует 5 уровней компиляции:  
  

-   0 — интерпретируемый код
-   1 — C1 с полной оптимизацией (без профилирования)
-   2 — C1 с учетом количества вызовов методов и итераций циклов
-   3 — С1 с профилированием
-   4 — С2

  
Типичные последовательности переходов между уровнями приведены в таблице.  

Последовательность  

Описание  

0-3-4

Интерпретатор, уровень 3, уровень 4. Наиболее частый случай.

0-2-3-4

Случай, когда очередь уровня 4 (C2) переполнена. Код быстро компилируется на уровне 2. Как только профилирование этого кода завершится, он будет скомпилирован на уровне 3 и, наконец, на уровне 4.

0-2-4

Случай, когда очередь уровня 3 переполнена. Код может быть готов к компилированию на уровне 4 все еще ожидая своей очереди на уровне 3. Тогда он быстро компилируется на уровне 2 и затем на уровне 4.

0-3-1

Случай простых методов. Код сначала компилируется на уровне 3, где становится понятно, что метод очень простой и уровень 4 не сможет скомпилировать его оптимальней. Код компилируется на уровне 1.

0-4

Многоуровневая компиляция выключена.

  

### Code cache

  
Машинный код, скомпилированный JIT компилятором, хранится в области памяти называемой code cache. В ней также хранится машинный код самой виртуальной машины, например, код интерпретатора. Размер этой области памяти ограничен, и когда она заполняется, компиляция прекращается. В этом случае часть «горячих» методов так и продолжит выполняться интерпретатором. В случае переполнения JVM выводит следующее сообщение:  
  

```
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full.
         Compiler has been disabled.
```

  
Другой способ узнать о переполнении этой области памяти — включить логирование работы компилятора (как это сделать обсуждается ниже).  
Code cache настраивается также как и другие области памяти в JVM. Первоначальный размер задаётся параметром **-XX:InitialCodeCacheSize**. Максимальный размер задается параметром **-XX:ReservedCodeCacheSize**. По умолчанию начальный размер равен 2496 KB. Максимальный размер равен 48 MB при выключенной многоуровневой компиляции и 240 MB при включенной.  
  
Начиная с Java 9 code cache разделен на 3 сегмента (суммарный размер по-прежнему ограничен пределами, описанными выше):  
  

-   JVM internal (non-method code). Содержит машинный код, относящийся к самой JVM, например, код интерпретатора. Размер этого сегмента зависит от количества потоков компиляции. На машине с четырьмя ядрами по умолчанию его размер составляет около 5.5 MB. Задать произвольный размер сегмента можно параметром **-XX:NonNMethodCodeHeapSize.**
-   Profiled code. Содержит частично оптимизированный машинный код с коротким временем жизни. Размер этого сегмента равен половине пространства оставшегося после выделения non-method code сегмента. По умолчанию это 21.2 MB при выключенной многоуровневой компиляции и 117.2 MB при включенной. Задать произвольный размер можно параметром **-XX:ProfiledCodeHeapSize**.
-   Non-profiled code. Содержит полностью оптимизированный код с потенциально долгим временем жизни. Размер этого сегмента равен половине пространства оставшегося после выделения non-method code сегмента. По умолчанию это 21.2 MB при выключенной многоуровневой компиляции и 117.2 MB при включенной. Задать произвольный размер можно параметром **-XX: NonProfiledCodeHeapSize**.

  

### Мониторинг работы компилятора

  
Включить логирование процесса компиляции можно флагом **-XX:+PrintCompilation** (по умолчанию он выключен). При установке этого флага JVM будет выводить в стандартный поток вывода (STDOUT) сообщение каждый раз после компиляции метода или цикла. Большинство сообщений имеют следующий формат: timestamp compilation_id attributes tiered_level method_name size deopt.  
  
Поле timestamp — это время со старта JVM.  
  
Поле compilation_id — это внутренний ID задачи. Обычно он последовательно увеличивается в каждом сообщении, но иногда порядок может нарушаться. Это может произойти в случае, если существует несколько потоков компиляции работающих параллельно.  
  
Поле attributes — это набор из пяти символов, несущих дополнительную информацию о скомпилированном коде. Если какой-то из атрибутов не применим, вместо него выводится пробел. Существуют следующие атрибуты:  
  

-   % — OSR (on-stack replacement);
-   s — метод является синхронизированным (synchronized);
-   ! — метод содержит обработчик исключений;
-   b — компиляция произошла в блокирующем режиме;
-   n — скомпилированный метод является оберткой нативного метода.

  
Аббревиатура OSR означает on-stack replacement. Компиляция — это асинхронный процесс. Когда JVM решает, что метод необходимо скомпилировать, он помещается в очередь. Пока метод компилируется, JVM продолжает исполнять его интерпретатором. В следущий раз, когда метод будет вызван снова, будет выполняться его скомпилированная версия. В случае долгого цикла ждать завершения метода нецелесообразно — он может вообще не завершиться. JVM компилирует тело цикла и должна начать исполнять его скомпилированную версию. JVM хранит состояние потоков в стеке. Для каждого вызываемого метода в стеке создается новый объект — Stack Frame, который хранит параметры метода, локальные переменные, возвращаемое значение и другие значения. Во время OSR создается новый объект Stack Frame, который заменяет собой предыдущий.  
  
![](https://habrastorage.org/r/w1560/webt/6e/qj/ai/6eqjaimq3bkpsx0isveuucg71xi.jpeg)  
  
Источник: [The Java HotSpotTM Virtual Machine Client Compiler: Technology and Application](http://www.reins.altervista.org/java/javaOne2001_2696.pdf)  
Атрибуты «s» и «!» в пояснении я думаю не нуждаются.  
  
Атрибут «b» означает, что компиляция произошла не в фоне, и не должен встречаться в современных версиях JVM.  
  
Атрибут «n» означает, что скомпилированный метод является оберткой нативного метода.  
Поле tiered_level содержит номер уровня, на котором был скомпилирован код или может быть пустым, если многоуровневая компиляция выключена.  
  
Поле method_name содержит название скомпилированного метода или название метода, содержащего скомпилированный цикл.  
  
Поле size содержит размер скомпилированного байт-кода, не размер полученного машинного кода. Размер указан в байтах.  
  
Поле deopt появляется не в каждом сообщении, оно содержит название проведенной деоптимизации и может содержать такие сообщения как «made not entrant» и «made zombie».  
Иногда в логе могут появиться записи вида: timestamp compile_id COMPILE SKIPPED: reason. Они означают, что при компиляции метода что-то пошло не так. Есть случаи, когда это ожидаемо:  
  

-   Code cache filled — необходимо увеличть размер области памяти code cache.
-   Concurrent classloading — класс был модифицирован во время компиляции.

  
Во всех случаях, кроме переполнения code cache, JVM попробует повторить компиляцию. Если этого не происходит, можно попробовать упростить код.  
  
В случае, если процесс был запущен без флага -XX:+PrintCompilation, взглянуть на процесс компиляции можно с помощью утилиты **jstat**. У jstat есть два параметра для вывода информации о компиляции.  
  
Параметр **-compiler** выводит сводную информацию о работе компилятора (5003 — это ID процесса):  
  

```
% jstat -compiler 5003
Compiled Failed Invalid   Time   FailedType FailedMethod
     206         0          0    1.97                0
```

  
Эта команда также выводит количество методов, компиляция которых завершилась ошибкой и название последнего такого метода.  
  
Параметр **-printcompilation** выводит информацию о последнем скомпилированном методе. В сочетании со вторым параметром — периодом повторения операции, можно наблюдать процесс компиляции с течением времени. В следующем примере команда -printcompilation выполняется каждую секунду (1000 мс):  
  

```
% jstat -printcompilation 5003 1000
Compiled  Size  Type Method
     207     64    1 java/lang/CharacterDataLatin1 toUpperCase
     208      5    1 java/math/BigDecimal$StringBuilderHelper getCharArray
```

### Счетчики вызовов методов и итераций циклов

Главным фактором влияющим на решение JVM о компиляции какого-либо кода является частота его исполнения. Решение принимается на основе двух счетчиков: счетчика количества вызовов метода и счетчика количества итераций циклов в методе.

Когда JVM исполняет какой-либо метод, она проверяет значения этих двух счетчиков, и принимает решение о необходимости его компиляции. У этого типа компиляции нет официального названия, но часто его называют стандартной компиляцией.

Аналогично, после каждой итерации цикла проверяется значение счетчика цикла и принимается решение о необходимости его компиляции.

При выключенной многоуровневой компиляции стандартная компиляция управляется параметром **-XX:CompileThreshold**. Значением по умолчанию является 10000. Несмотря на то, что параметр всего один, превышение порога определяется суммой значений двух счетчиков. В настоящее время этот флаг ни на что не влияет (многоуровневая компиляция включена по умолчанию), но знать о нем полезно, ведь существует довольно много унаследованных систем.

Ранее уменьшением значения этого параметра добивались ускорения старта приложения при использовании серверного компилятора, поскольку это приводило к более ранней компиляции кода. Также уменьшение его значения могло способствовать компиляции методов, которые иначе никогда бы не скомпилировались.

Последнее утверждение довольно интересно. Ведь если программа исполняется бесконечно, не должен ли весь ее код в конце концов скомпилироваться? На самом деле не должен, поскольку значения счетчиков не только увеличиваются при каждом вызове метода или итерации цикла, но и периодически уменьшаются. Таким образом, они являются отражением текущего «нагрева» метода или цикла.

Получается, что до внедрения многоуровневой компиляции методы, выполнявшиеся довольно часто, но недостаточно часто, чтобы превысить порог, никогда бы не были скомпилированы. В настоящее время такие методы будут скомпилированы компилятором C1, хотя, возможно, их производительность была бы выше, будь они скомпилированы компилятором C2. При желании можно поиграть параметрами **-XX:Tier3InvocationThreshold** (значение по умолчанию 200) и **-XX:Tier4InvocationThreshold** (значение по умолчанию 5000), но вряд ли в этом есть большой практический смысл. Такие же параметры (**-XX:TierXBackEdgeThreshold**) существуют и для задания пороговых значений счетчиков циклов.

### Потоки компиляции

Как только JVM решает скомпилировать метод или цикл, они помещаются в очередь. Эта очередь приоритетная - чем выше значения счетчиков, тем выше приоритет. Это особенно помогает при старте приложения, когда необходимо компилировать огромное количество кода. Таким образом, более важный код будет скомпилирован раньше.

Компиляторы C1 и C2 имеют собственные очереди, каждая из которых может обрабатывается несколькими потоками. Существует специальная формула для вычисления количества потоков в зависимости от количества ядер. Некоторые значения приведены в таблице:

![[Pasted image 20230111173328.png]]

Задать произвольное количество потоков можно параметром **-XX:CICompilerCount**. Это общее количество потоков компиляции, которое будет использовать JVM. При включенной многоуровневой компиляции одна треть из них (но минимум один) будут отданы компилятору C1, остальные достанутся компилятору C2. Значением по умолчанию для этого флага является сумма потоков из таблицы выше. При выключенной многоуровневой компиляции все потоки достанутся компилятору C2.

В каком случае имеет смысл менять настройки по умолчанию? Ранние версии Java 8 (до update 191) при запуске в Docker контейнере не корректно определяли количество ядер. Вместо количества ядер, выделенных контейнеру определялось количество ядер на сервере. В этом случае есть смысл задать количество потоков вручную, исходя из значений, приведенных в таблице выше.

Аналогично, при запуске приложения в одноядерной виртуальной машине может оказаться предпочтительнее иметь только один поток компиляции, чтобы избежать борьбы за процессорное время. Но надо иметь ввиду, что выгода от наличия всего одного потока проявляется только при старте и «прогреве» приложения, после этого количество методов, ожидающих компиляцию, будет не велико.

Еще один параметр, влияющий на количество потоков компиляции - это **-XX:+BackgroundCompilation**. Его значение по умолчанию - true. Он означает, что компиляция должна происходить в асинхронном режиме. Если установить его в false, каждый раз при наличии кода, который необходимо скомпилировать, JVM будет ожидать завершения компиляции, прежде чем этот код исполнить.

### Оптимизации

Как мы знаем, JVM использует результаты профилирования методов в процессе компиляции. JVM хранит данные профиля в объектах, называемых method data objects (MDO). Объекты MDO используются интерпретатором и компилятором C1 для записи информации, которая затем используется для принятия решения о том, какие оптимизации возможно применить к компилируемому коду. Объекты MDO хранят информацию о вызванных методах, выбранных ветвях в операторах ветвления, наблюдаемых типах в точках вызова. Как только принято решение о компиляции, компилятор строит внутреннее представление компилируемого кода, которое затем оптимизируется. Компиляторы способны проводить широкий набор оптимизаций, включающий:

-   встраивание (inlining);
    
-   escape-анализ (escape-analysis);
    
-   размотка (раскрутка) цикла (loop unrolling);
    
-   мономорфная диспетчеризация (monomorphic dispatch);
    
-   intrinsic-методы.
    

### Встраивание

Встраивание - это копирование вызываемого метода в место его вызова. Это позволяет устранить накладные расходы, связанные с вызовом метода, такие как:

-   подготовка параметров;
    
-   поиск по таблице виртуальных методов;
    
-   создание и инициализация объекта Stack Frame;
    
-   передача управления;
    
-   опциональный возврат значения.
    

Встраивание является одной из оптимизаций, выполняемых JVM в первую очередь, оно включено по умолчанию. Отключить его можно флагом **-XX:-Inline**, хотя делать этого не рекомендуется. JVM принимает решение о необходимости встраивания метода на основе нескольких факторов, некоторые из которых приведены ниже.

-   Размер метода. «Горячие» методы являются кандидатами для встраивания если их размер меньше 325 байт (или меньше размера заданного параметром **-XX:MaxFreqInlineSize**). Если метод вызывается не так часто, он является кандидатом для встраивания только если его размер меньше 35 байт (или меньше размера заданного параметром **-XX:MaxInlineSize**).
    
-   Позиция метода в цепочке вызовов. Не подлежат встраиванию методы с позицией больше 9 (или значения заданного параметром **-XX:MaxInlineLevel**).
    
-   Размер памяти, занимаемой уже скомпилированными версиями метода в code cache. Встраиванию не подлежат методы, скомпилированные на последнем уровне, версии которых занимают более 1000 байт при выключенной многоуровневой компиляции и 2000 байт при включенной (или значения заданного параметром **-XX:InlineSmallCode**).
    

### Escape-анализ

Escape-анализ - это техника анализа кода, которая позволяет определить пределы достижимости какого-либо объекта. Например, escape-анализ может использоваться для определения является ли объект созданный внутри метода достижимым за пределами области видимости метода. Сам по себе escape-анализ не является оптимизацией, но оптимизации могут выполняются по его результатам.

#### Предотвращение выделений памяти в куче

Создание новых объектов внутри циклов может создать нагрузку на систему выделения памяти. Создание большого числа короткоживущих объектов потребует частых сборок мусора в молодом поколении. Если частота создания объектов будет достаточно большой, короткоживущие объекты могут попасть и в старое поколение, что потребует уже «дорогостоящей» полной сборки мусора. Если JVM убедится, что объект не достижим за пределами области видимости метода, она может применить технику оптимизации, называемую скаляризация. Поля объекта станут скалярными значениями и будут храниться в регистрах процессора. Если регистров не достаточно, скалярные значения могут храниться в стеке.

#### Блокировки и escape-анализ

JVM способна использовать результаты escape-анализа для оптимизации производительности блокировок. Это относится только к блокировкам с помощью ключевого слова synchronized, блокировки из пакета java.util.concurrent таким оптимизациям не подвержены. Возможными оптимизации приведены ниже.

-   Удаление блокировок с объектов недостижимых за пределами области видимости (lock elision).
    
-   Объединение последовательных синхронизированных секций, использующих один и тот же объект синхронизации (lock coarsening). Выключить эту оптимизацию можно флагом **-XX:-EliminateLocks**.
    
-   Определение и удаление вложенных блокировок на одном и том же объекте (nested locks). Выключить эту оптимизацию можно флагом **-XX:-EliminateNestedLocks**.
    

#### Ограничения escape-анализа

Поскольку регистры процессора и стек являются ресурсами довольно ограниченными, существуют ограничения и на их использование. Так, например, массивы размером более 64 элементов не участвуют в escape-анализе. Этот размер можно задавать параметром **-XX:EliminateAllocationArraySizeLimit**. Представьте код, создающий временный массив в цикле. Если массив не достижим за пределами метода, массив не должен создаваться в куче. Но если его размер больше 64 элементов, он будет создаваться именно там, даже при условии, что реально используется не весь массив.

Еще одно ограничение заключается в том, что частичный escape-анализ не поддерживается. Если объект выходит за пределы области видимости метода хотя бы по одной из веток, оптимизация по предотвращению создания объекта в куче не применима. Пример подобного кода приведен ниже.

```
for (int i = 0; i < 100_000_000; i++) {
    Object mightEscape = new Object(i);
    if (condition) {
        result += inlineableMethod(mightEscape);
    } else {
        result += tooBigToInline(mightEscape);
    }
}
```

Но если вам удастся локализовать создание объекта внутри ветки, в которой объект не выходит за пределы области видимости, то данная оптимизация будет применена в этой ветке.

```
if (condition) {
        Object mightEscape = new Object(i);
        result += inlineableMethod(mightEscape);
    } else {
        Object mightEscape = new Object(i);
        result += tooBigToInline(mightEscape);
    }
}
```

### Размотка (раскрутка) цикла

После встраивания всех возможных вызовов методов внутри цикла, JVM может оценить «стоимость» каждой его итерации, и определить возможность применения оптимизации, называемой размотка (раскрутка) цикла. Размотка цикла - это техника оптимизации компьютерных программ, состоящая в искусственном увеличении количества инструкций, исполняемых в течение одной итерации цикла. Каждая итерация цикла оказывает отрицательное влияние на работу процессора, т.к. сбрасывает конвейер инструкций. Чем короче тело цикла, тем выше «стоимость» итерации.

В результате размотки цикла такой код:

```
int i;
for ( i = 1; i < n; i++)
{
    a[i] = (i % b[i]);
}
```

преобразуется в код вида:

```
int i;
for (i = 1; i < n - 3; i += 4)
{
    a[i] = (i % b[i]);
    a[i + 1] = ((i + 1) % b[i + 1]);
    a[i + 2] = ((i + 2) % b[i + 2]);
    a[i + 3] = ((i + 3) % b[i + 3]);
}

for (; i < n; i++) 
{
    a[i] = (i % b[i]);
}
```

JVM принимает решение о размотке цикла по нескольким критериям:

-   по типу счетчика цикла, он должен быть одним из типов int, short или char;
    
-   по значению, на которое меняется счетчик цикла каждую итерацию;
    
-   по количеству точек выхода из цикла.
    

### Мономорфная диспетчеризация

Многие оптимизации, выполняемые компилятором C2 основаны на эмпирических наблюдениях. Одним из примеров является оптимизация под названием мономорфная диспетчеризация. Она основана на факте, что очень часто в точках вызова тип объекта во время выполнения остается неизменным. Это связано с особенностями объектно-ориентированного дизайна. Например, при вызове метода на объекте, наблюдаемый тип объекта при первом и последующих вызовах будет одним и тем же. Если это предположение верно, то вызов метода в этой точке можно оптимизировать. В частности, нет необходимости каждый раз выполнять поиск по таблице виртуальных методов. Достаточно один раз определить целевой тип объекта и заменить вызов виртуального метода быстрой проверкой типа и прямым вызовом метода на объекте целевого типа. Если в какой-то момент тип объекта поменяется, JVM откатит оптимизацию и будет снова выполнять вызов виртуального метода.

Большое число вызовов в типичном приложении являются мономорфными. JVM также поддерживает биморфную диспетчеризацию. Она позволяет делать быстрые вызовы методов в одной точке на объектах двух разных типов.

Вызовы, которые не являются ни мономорфными ни биморфными, называются мегаморфными. Если в точке вызова наблюдается не очень большое число типов, используя один трюк, можно немного выиграть в производительности. Достаточно «отделить» от точки вызова несколько типов, используя оператор instanceof так, чтобы в ней осталось только 2 конкретных типа. Примеры биморфного, мегаморфного и разделенного мегаморфного вызовов приведены ниже.

```
interface Shape {
	int getSides();
}

class Triangle implements Shape {
	public int getSides() {
		return 3;
	}
}

class Square implements Shape {
	public int getSides() {
		return 4;
	}
}

class Octagon implements Shape {
	public int getSides() {
		return 8;
	}
}

class Example {
  private Random random = new Random();
	private Shape triangle = new Triangle();
	private Shape square = new Square();
	private Shape octagon = new Octagon();

	public int getSidesBimorphic() {
		Shape currentShape = null;
		switch (random.nextInt(2)) {
		case 0:
			currentShape = triangle;
			break;
		case 1:
			currentShape = square;
			break;
		}
		return currentShape.getSides();
	}

  public int getSidesMegamorphic() {
    Shape currentShape = null;
    switch (random.nextInt(3))
    {
    case 0:
      currentShape = triangle;
      break;
    case 1:
      currentShape = square;
      break;
    case 2:
      currentShape = octagon;
      break;
    }
    return currentShape.getSides();
	}

  public int getSidesPeeledMegamorphic() {
    Shape currentShape = null;
    switch (random.nextInt(3))
    {
    case 0:
      currentShape = triangle;
      break;
    case 1:
      currentShape = square;
      break;
    case 2:
      currentShape = octagon;
      break;
    }

    // peel one observed type from the original call site
    if (currentShape instanceof Triangle) {
      return ((Triangle) currentShape).getSides();
    }
    else {
      return currentShape.getSides(); // now only bimorphic
    }
	}
}
```

### Intrinsic-методы

Intrinsic-методы - это оптимизированные нативные реализации методов готовые к использованию JVM. Обычно это базовые, критичные к производительности методы, использующие специфичные функции операционной системы (ОС) или архитектуры процессора. Из-за этого они являются платформо-зависимыми и некоторые из них могут поддерживаться не каждой платформой. Примеры intrinsic-методов приведены в таблице ниже.

![[Pasted image 20230111173350.png]]

Шаблоны intrinsic-методов содержатся в исходном коде OpenJDK в файлах с расширением .ad (architecture dependent). Для архитектуры x86_64 они находятся в файле hotspot/src/cpu/x86/vm/x86_64.ad.

### Деоптимизации

Когда мы рассматривали мониторинг работы компилятора в первой части, мы упомянули, что в логе могут появиться сообщения о деоптимизации кода. Деоптимизация означает откат ранее скомпилированного кода. В результате деоптимизации производительность приложения будет временно снижена. Существует два вида деоптимизации: недействительный код (not entrant code) и зомби код (zombie code).

### Недействительный код

Код может стать недействительным в двух случаях:

-   при использовании полиморфизма;
    
-   в случае многоуровневой компиляции.
    

#### Полиморфизм

Рассмотрим пример:

```
Validator validator;
if (document.isOrder()) {
  validator = new OrderValidator();
} else {
  validator = new CommonValidator();
}
ValidationResult validationResult = validator.validate(document);
```

Выбор валидатора зависит от типа документа. Пусть для заказов у нас есть собственный валидатор. Предположим, что необходимо провалидировать большое количество заказов. Компилятор зафиксирует, что всегда используется валидатор заказов. Он встроит метод validate (если это возможно) и применит другие оптимизации. Далее, если на валидацию придет документ другого типа, предыдущее предположение окажется неверным, и сгенерированный код будет помечен как недействительный (non entrant). JVM перейдет на интерпретацию этого кода, и в будущем сгенерирует новую его версию.

#### Многоуровневая компиляция

В случае многоуровневой компиляции, когда код компилируется на новом уровне, его предыдущая версия также помечается недействительной.

### Зомби код

Если в логе компиляции появилось сообщение о зомби коде, это значит, что все объекты, использующие предыдущие оптимизации были удалены из памяти и, как следствие, из code cache был удален код, ранее помеченный недействительным.
## AOT
Недавно [стало](https://openjdk.java.net/jeps/295) окончательно известно — в Java 9 будет AOT-компиляция. Мы решили рассказать о том, как это будет, зачем это нужно, а также развеять несколько устойчивых мифов, которые сложились вокруг статической и динамической компиляции.

#### Какая-какая компиляция?

Статическая, или Ahead-Of-Time (AOT) компиляция — это самая обычная компиляция, которую мы привыкли видеть в языке Си. Исходный код превращается в исполняемый, и на выходе получается исполняемый файл, который можно запустить позже. На статическую компиляцию требуется дополнительное время до начала работы программы, отсюда и название. Существует ещё динамическая, или Just-In-Time (JIT) компиляция — она осуществляется прямо во время работы программы, «на лету». Именно она и используется в Java в настоящий момент.

#### А в Java 9 хотят заменить её на статическую?

Нет. В Java 9 планируют добавить возможность AOT-компилятор в качестве альтернативы (но не замены) существующим инструментам. Утилита будет называться `jaotc`. В Java 9 она гарантированно будет работать только для модуля `java.base`, который содержит всё необходимое для работы с объектами, потоками и структурами данных — то, без чего не может обойтись ни одно приложение. Исходя из этого, AOT-компиляцию в Java 9 всё ещё можно назвать лишь экспериментальной возможностью.

#### А зачем это нужно?

AOT-компиляция имеет несколько специфических преимуществ. Во-первых, это защита от декомпиляции. Байткод Java можно без особого труда декомпилировать в код на Java, и, таким образом, взломать программу (которая, например, требует лицензионный ключ). Исполняемый код же можно лишь дизассемблировать, и, думается, любой может сравнить сложность поиска каких-то деталей в коде на Java и ассемблерном коде. Обфускация же далеко не панацея, т.к. она трудно реализуема при активном использовании рефлексии и всё равно не даёт стопроцентной защиты. Во-вторых, стоит обратить внимание на время запуска приложения. Для первого запуска (так называемого «холодного старта») приложению требуется значительное количество времени. Для скомпилированного статически кода на Java стартовое время [не отличается](https://www.youtube.com/watch?v=blXQTBiYbzs) от старта аналогичной программы на Си:  
[![aot1](https://media.tproger.ru/uploads/2016/10/aot1.png)](https://media.tproger.ru/uploads/2016/10/aot1.png)

#### То есть, получается, со статической компиляцией мы получим в Java скорость Си?

Нет. Си достигает значительной скорости за счёт многих допущений небезопасного поведения. Например, в случае выхода за границы массива в Си случится [segfault](https://ru.wikipedia.org/wiki/%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0_%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8) (в лучшем случае), а в Java просто вылетит `ArrayOutOfBoundsException`. Подобные проверки не бесплатны, за них приходится платить производительностью как в случае динамической компиляции, так и в случае статической.

Неверным также является представление, что Си в целом работает быстрее Java. Так, в Java компилятору доступен весь код всех подключенных библиотек, а значит, он может оптимизировать их работу наиболее выгодным для данного приложения путём. В Си же библиотеки могут подключаться в виде машинного кода, и никакие дополнительные оптимизации для них недоступны.

#### Так значит, JIT для Java подходит лучше? Это ведь всё-таки динамический язык.

Такое утверждение тоже будет неверным. Оптимизации, которые производит компилятор, могут быть достаточно сложными и ресурсоёмкими, могут требовать итеративного пересчёта и анализа всей программы целиком. Зачастую в процессе оптимизации возникает такое количество дополнительных данных, что хранить их в оперативной памяти невозможно, и требуется их промежуточная запись на диск. Всего этого JIT-компилятор просто не может себе позволить. Очень заметна разница в производительности между JIT-исполняемым кодом и AOT-компилированным, например, при работе с элементами пользовательского интерфейса.

#### Что-то я совсем запутался. Так что же лучше?

На этот вопрос нельзя дать однозначного ответа. Для разных приложений и для разных целей выбор может быть разным. Главное, что теперь он будет. Конечно, AOT-компиляторы Java существовали и раньше, однако мало кто из них может похвастаться полноценной поддержкой свежих спецификаций Java. Теперь, когда за дело взялись специалисты из Oracle, возможно, ситуация изменится в лучшую сторону. Про AOT-компиляцию Java кода есть отличный доклад Никиты Липского, на который мы в основном и опирались при подготовке данной статьи:

#### Можно привести пример, в каких ситуациях статическая компиляция будет явно лучше, чем JIT?

При разработке для встраиваемых систем и мобильных платформ, скорее всего, AOT-компиляция будет лучшим выбором. Встраиваемые системы чаще всего не обладают теми же вычислительными мощностями, что и настольные компьютеры или сервера, а чем слабее железо, тем дороже динамическая компиляция. В случае с мобильными устройствами решающую роль играет другой фактор — нагрузка на аккумулятор. Динамическая компиляция требует много большего расхода энергии, чем выполнение уже скомпилированного кода. Так, для iOS политика распространения приложений вовсе запрещает любую динамическую загрузку кода, поэтому Java фактически невозможно использовать для программирования под устройства Apple.
## Процесс компиляции в байт-код
![Компиляция и исполнение Java приложений под капотом - 2](https://cdn.javarush.com/images/article/fef10693-b1f3-479a-a02e-29414cdc2a79/1080.webp)

Начнем с теории. Когда мы пишем какое-либо приложение, мы создаем файл с расширением `.java` и помещаем в него код на языке программирования Java. Такой файл, содержащий код, понятный человеку, называется **файлом с исходным кодом**. После того, как файл с исходным кодом готов, нужно его выполнить! Но на стадии в нем содержится информация, понятная только человеку. Java — мультиплатформенный язык программирования. Это значит, что программы, написанные на языке Java, можно выполнять на любой платформе, где установлена специальная исполняющая система Java. Такая система называется Java Virtual Machine (JVM). Для того, чтобы перевести программу из исходного кода в код, понятный JVM, нужно её скомпилировать. Код, понятный JVM называется байт-кодом и содержит набор инструкций, которые в дальнейшем будет исполнять виртуальная машина. Для компиляции исходного кода в байт-код существует компилятор `javac`, входящий в поставку JDK (Java Development Kit). На вход компилятор принимает файл с расширением `.java`, содежащий исходный код программы, а на выходе выдает файл с расширением `.class`, содержащий байт-код, необходимый для исполнения программы виртуальной машиной. После того, как программа была скомпилирована в байт-код, она может быть выполнена с помощью виртуальной машины.

### Пример компиляции и выполнения программы

Предположим, что у нас есть простая программа, содержащаяся в файле `Calculator.java`, которая принимает 2 численных аргумента командной строки и печатает результат их сложения:

`class Calculator {     public static void main(String[] args){         int a = Integer.valueOf(args[0]);         int b = Integer.valueOf(args[1]);          System.out.println(a + b);     } }`

Для того, чтобы скомпилировать эту программу в байт-код, воспользуемся компилятором `javac` в командной строке:

`javac Calculator.java`

После компиляции на выходе мы получаем файл с байт-кодом `Calculator.class`, который мы можем исполнить при помощи установленной на нашем компьютере java-машины командой java в командной строке:

`java Calculator 1 2`

Заметим, что после названия файла были указаны 2 аргумента командной строки — числа 1 и 2. После выполнения программы, в командной строке выведется число 3. В примере выше у нас был простой класс, который живет сам по себе. Но что, если класс находится в каком либо пакете? Смоделируем такую ситуацию: создадим директории `src/ru/javarush` и поместим туда наш класс. Теперь он выглядит следующим образом (добавили имя пакета в начале файла):

`package ru.javarush;  class Calculator {     public static void main(String[] args){         int a = Integer.valueOf(args[0]);         int b = Integer.valueOf(args[1]);          System.out.println(a + b);     } }`

Скомпилируем такой класс следующей командой:

`javac -d bin src/ru/javarush/Calculator.java`

В этом примере мы использовали дополнительную опцию компилятора `-d bin`, которая складывает скомпилированные файлы в директорию `bin` со структурой, аналогичной директории `src`, при этом директория `bin` должна быть создана заранее. Такой прием используется, чтобы не путать файлы с исходным кодом с файлами с байт-кодом. Перед запуском скомпилированной программы стоит пояснить понятие `classpath`. `Classpath` — это путь, относительно которого виртуальная машина будет искать пакеты и скомпилированные классы. Тоесть, таким образом мы говорим виртуальной машине какие директории в файловой системе являются корневыми для иерархии пакета Java. `Classpath` можно укзать при запуска программы с помощью флага `-classpath`. Запуск программы осуществляем с помощью команды:

`java -classpath ./bin ru.javarush.Calculator 1 2`

В этом примере нам потребовалось указать полное имя класса, включая имя пакета, в котором он находится. Финальное дерево файлов выглядит следующим образом:

`├── src │     └── ru │          └── javarush │                  └── Calculator.java └── bin       └── ru            └── javarush                    └── Calculator.class`

### Выполнение программы виртуальной машиной

Итак, мы запустили написанную программу. Но что же происходит в момент запуска скомпилированной программы виртуальной машиной? Для начала разберемся, что означают понятия компиляции и интерпретации кода. **Компиляция** — трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду. **Интерпретация** — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения). Язык Java обладает как компилятором (`javac`), так и интерпретатором, в роли которого выступает виртуальная машина, которая построчно преобразует байт-код в машинный код и тут же его исполняет. Таким образом, когда мы запускаем скомпилированную программу, виртуальная машина начинает её интерпретацию, то есть построчное преобразование байт-кода в машинный код, а так же его исполнение. К сожалению, чистая интерпретация байт-кода является довольно долгим процессом и делает язык java медленным в сравнении с его конкурентами. Дабы избежать этого, был введен механизм, позволяющий ускорить интерпретацию байт-кода виртуальной машиной. Этот механизм называется Just-in-time компиляцией (JITC).

### Just-in-time (JIT) компиляция

Простыми словами, механизм Just-In-Time компиляции заключается в следующем: если в программе присутствуют части кода, которые выполняются много раз, то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение. После компиляции такой части программы в машинный код, при каждом следующем вызове этой части программы виртуальная машина будет сразу выполнять скомпилированный машинный код, а не интерпретировать его, что естественно ускорит выполнение программы. Ускорение работы программы достигается за счет увеличения потребления памяти (где-то же нам нужно хранить скомпилированный машинный код!) и за счет увеличения временных затрат на компиляцию во время исполнения программы. JIT компиляция — довольно сложный механизм, поэтому пройдемся по верхам. Всего существует 4 уровня JIT компиляции байт-кода в машинный код. Чем выше уровень компиляции, тем он сложнее, но и одновременно выполнение такого участка будет быстрее, чем участка с меньшим уровнем. JIT — компилятор самостоятельно решает, какой уровень компиляции задать для каждого фрагмента программы на основе того, как часто выполняется этот фрагмент. Под капотом JVM использует 2 JIT-компилятора — C1 и C2. C1 компилятор так же называется клиентским компилятором и способен скомпилировать код только до 3-его уровня. За 4-ый, самый сложны и быстрый уровень компиляции отвечает компилятор C2.

![Компиляция и исполнение Java приложений под капотом - 3](https://cdn.javarush.com/images/article/59e6a0ff-a9cc-4570-82b9-ff2c047cade0/1080.webp)

Из вышесказанного можно сделать вывод о том, что для простых, клиентских приложений, выгоднее использовать компилятор C1, так как в этом случае нам важно как быстро стартует приложение. Серверные, долгоживущие приложения могут стартовать большее количество времени, однако в дальнейшем должны работать и выполнять свою функцию быстро — тут нам подойдет компилятор C2.

При запуске Java — программы на x32 версии JVM мы в ручную можем указать, какой режим мы хотим использовать, при помощи флагов `-client` и `-server`. При указании флага `-client` JVM не будет производить сложные оптимизации с байт-кодом, что ускорит время старта приложения и уменьшит количество потребляемой памяти. При указании флага `-server` приложение будет стартовать большее количество времени из-за сложных оптимизаций байт-кода и будет использовать больше памяти для хранения машинного кода, однако в дальнейшем работать такая программа будет быстрее. В x64 версии JVM флаг `-client` игнорируется и по умолчанию используется серверная конфигурация приложения.

### Заключение

Вот и подошел к концу мой краткий обзор того, как работает компиляция и исполнение Java-приложения. Основные поинты:

1.  Компилятор _javac_ преобразует исходный код программы в байт-код, который может быть выполнен на любой платформе, на которой установлена виртуальная машина Java;
    
2.  После компиляции JVM интерпретирует получившийся байт-код;
    
3.  Для ускорения работы Java-приложений, JVM использует механизм Just-In-Time компиляции, который преобразует наиболее часто выполняемые участки программы в машинный код и хранит их в памяти.

## client-jvm vs. server-jvm
**В чем разница между системами -client и -server?**

Эти две системы являются разными двоичными файлами. По сути, это два разных компилятора (JIT), взаимодействующих с одной и той же системой времени выполнения. Клиентская система оптимальна для приложений, которым требуется быстрое время запуска или небольшие размеры, серверная система оптимальна для приложений, где общая производительность наиболее важна. В целом, клиентская система лучше подходит для интерактивных приложений, таких как GUI. Некоторые из других отличий включают политику компиляции, настройки кучи по умолчанию и политику встраивания.

[![](https://4.bp.blogspot.com/-jf3XClT5seg/TiMiYZm3hpI/AAAAAAAAAEk/8o_q2AZyJaQ/s1600/client-server-plug.gif)](https://4.bp.blogspot.com/-jf3XClT5seg/TiMiYZm3hpI/AAAAAAAAAEk/8o_q2AZyJaQ/s1600/client-server-plug.gif)

Согласно « [Архитектуре Java HotSpot Performance Engine](https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=http://java.sun.com/products/hotspot/whitepaper.html&usg=ALkJrhhIknXZkGQnqAceIQeBZPx51BpgWQ) »:

JDK включает в себя два варианта виртуальной машины — предложение на стороне клиента и виртуальную машину, настроенную для серверных приложений. Эти два решения совместно используют базу кода среды выполнения Java HotSpot, но используют разные компиляторы, которые соответствуют совершенно уникальным характеристикам производительности клиентов и серверов. Эти различия включают политику компиляции компиляции и значения по умолчанию для кучи.

JDK содержит обе эти системы в дистрибутиве, поэтому разработчики могут выбрать, какую систему они хотят, указав -client или -server.

Хотя виртуальные машины сервера и клиента похожи, виртуальная машина сервера была специально настроена для максимизации пиковой скорости работы. Он предназначен для запуска долго работающих серверных приложений, которым требуется максимально высокая скорость работы, превышающая быстрое время запуска или меньший объем памяти во время выполнения.

Компилятор клиентской виртуальной машины служит обновлением как для классической виртуальной машины, так и для JIT-компиляторов, используемых в предыдущих версиях JDK. Клиентская виртуальная машина предлагает улучшенную производительность во время выполнения для приложений и апплетов. Клиентская виртуальная машина Java HotSpot была специально настроена для уменьшения времени запуска приложения и использования памяти, что делает его особенно подходящим для клиентских сред. В целом, клиентская система лучше для GUI.

Компилятор виртуальной машины клиента не пытается выполнить многие из более сложных оптимизаций, выполняемых компилятором на виртуальной машине сервера, но в обмен на это требуется меньше времени для анализа и компиляции фрагмента кода. Это означает, что клиентская виртуальная машина может запускаться быстрее и требует меньшего объема памяти.

Примечание. Похоже, что основной причиной различий в производительности является количество оптимизаций.

Виртуальная машина сервера содержит усовершенствованный адаптивный компилятор, который поддерживает многие из тех же типов оптимизации, которые выполняются путем оптимизации компиляторов C ++, а также некоторые оптимизации, которые не могут быть выполнены традиционными компиляторами, такие как агрессивное встраивание между вызовами виртуальных методов. Это конкурентное и эксплуатационное преимущество перед статическими компиляторами. Технология адаптивной оптимизации очень гибка в своем подходе и обычно превосходит даже передовые методы статического анализа и компиляции.

Оба решения обеспечивают чрезвычайно надежную, безопасную и поддерживаемую среду для удовлетворения потребностей современных корпоративных клиентов.

Варианты по умолчанию:

-   Для Hotspot это клиент
-   Для JRockit это сервер

**Параметры клиентской и серверной виртуальной машины JRockit**  
JRockit также имеет эти две опции с опцией сервера по умолчанию (Hotspot является клиентом).  
Опция клиента JRockit — -client, а сервер — -jrockit.

**Практический пример разницы в производительности**  
Пример взят из [блога Онкара Джоши,](https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=http://www.onkarjoshi.com/blog/174/hotspot-jvm-client-server-vm-optimization/&usg=ALkJrhjWf8B8yvgJW_KlNEotmd7NgY0kCg) который доказывает разницу в производительности.

Мы запускаем следующий код с обоими переключателями:

`package` `com.blogspot.sdoulger;`

`public` `class` `LoopTest {`

    `public` `LoopTest() {`

        `super``();`

    `}`

    `public` `static` `void` `main(String[] args) {`

        `long` `start = System.currentTimeMillis();`

        `spendTime();`

        `long` `end = System.currentTimeMillis();`

        `System.out.println(``"Time spent: "``+ (end-start));`

        `LoopTest loopTest =` `new` `LoopTest();`

    `}`

    `private` `static` `void` `spendTime() {`

        `for` `(``int` `i =``500000000``;i>``0``;i--) {`

        `}`

    `}`

`}`

Примечание: код был скомпилирован только один раз! Классы одинаковы в обоих заездах!

**С -клиентом:**  
java.exe -client -classpath C: \ JDeveloper \ mywork \ Test_java_client-server_switches \ Project1 \ classes com.blogspot.sdoulger.LoopTest  
Потрачено времени: 766

**С -сервером:**  
java.exe -server -classpath C: \ JDeveloper \ mywork \ Test_java_client-server_switches \ Project1 \ classes com.blogspot.sdoulger.LoopTest  
Потраченного времени: 0