Как помогает в программировании

TransactionalFactory
ConnectionProvide

OpenSession vs. GetCurrentSession
Типы стратегии кэша в Hibernate
HQL и его преимущества

Join в Hibernate
Можно ли использовать nativeSQL запросы в Hibernate?
Как управлять транзакциями с помощью Hibernate
Что такое каскадные связи и какие есть?
Как интегрировать Hibernate в Spring
Паттерны в Hibernate?


## Hibernate
Hibernate Framework — это фреймворк для языка [Java](https://blog.skillfactory.ru/java-komu-i-dlya-chego-nuzhen/), предназначенный для работы с [базами данных](https://blog.skillfactory.ru/glossary/baza-dannyh/). Он реализует [объектно-реляционную модель](https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/) — технологию, которая «соединяет» программные сущности и соответствующие записи в базе. Иногда его называют библиотекой — оба названия в принципе справедливы.

Объектно-реляционная модель, или ORM, позволяет создать программную «виртуальную» базу данных из объектов. Объекты описываются на языках программирования с применением принципов ООП. Java Hibernate — популярное воплощение этой модели.

Hibernate построен на спецификации JPA 2.1 — наборе правил, который описывает взаимодействие программных объектов с записями в базах данных. JPA поясняет, как управлять сохранением данных из кода на Java в базу. Но сама по себе спецификация — только теоретические правила, а в «чистой» Java ее реализации нет. Hibernate — одна из самых популярных реализаций JPA на рынке.

Фреймворк бесплатный, с открытым исходным кодом, который может просмотреть любой программист. По-русски название читается как «хибернейт».

### Для чего применяется Hibernate

Hibernate пользуются Java-разработчики, которые работают с базами данных или с обработкой информации для последующего переноса в базу. Фреймворк используют при создании информационных систем: приложений, крупных программ и сетей, которые работают с информацией и базами данных. Существует аббревиатура CRUD, означающая Create, Read, Update, Delete: создавать, читать, обновлять и удалять. Это четыре действия, которые должна уметь выполнять информационная система, работающая с базой. Задача Hibernate при создании такого приложения — сократить количество низкоуровневого кода и облегчить работу программиста с БД.

![](https://blog.skillfactory.ru/wp-content/uploads/2022/06/hibernate-1-5074003.png)

Hibernate:

-   ускоряет и облегчает написание кода;
-   позволяет создать удобную модель для отображения базы данных в коде;
-   дает возможность быстро и в читаемом виде записывать информацию из кода в базу.

### Особенности Hibernate Framework

Идея фреймворка — создать «виртуальную» базу данных из программных объектов и работать с ней как с реальной базой. Поэтому им часто пользуются для упрощения работы. Он берет на себя взаимодействие с реляционной БД, а разработчику остается работать с кодом.

В Hibernate есть возможность, которую называют «ленивой загрузкой». Объекты в фреймворке не подгружают всю информацию из базы изначально. Вместо этого они просто «знают», как ее получить, и при первом обращении к информации загружают ее в фоне. Это нужно для оптимизации производительности.

Внутри Hibernate — собственный язык запросов Hibernate Query Language, или HQL. Это SQL-подобный язык, но полностью объектно-ориентированный и более краткий — не приходится так много работать с шаблонным кодом, как в «чистом» [SQL](https://blog.skillfactory.ru/glossary/sql/).

### Преимущества использования Hibernate

**Популярность.** Hibernate — популярный фреймворк, который фактически считают золотым стандартом. Это влечет за собой сразу три преимущества:

-   по нему много учебников, туториалов и обсуждений на специализированных сайтах;
-   большинство технологий, работающих с Java, поддерживают Hibernate. Это базы данных, фреймворки, библиотеки. Существуют плагины и для других языков или платформ, например порт на платформу .NET;
-   разработчик, умеющий работать с этим фреймворком, всегда найдет работу.

**Устранение лишнего кода.** Повторяющийся шаблонный код, который делает программу менее читаемой, называют «спагетти». Если программа взаимодействует с базой, то в ней по определению много «спагетти»-кода, в том числе низкоуровневого. Использование Hibernate позволяет сократить количество «спагетти», соответственно, сделать программу более лаконичной и хорошо читаемой.

**Возможность сосредоточиться на логике.** Разработчику не приходится писать множество запросов, он избавлен от написания большого количества «технического» низкоуровневого кода. Поэтому можно сосредоточиться на логике работы программы и не отвлекаться на шаблонные задачи, поручив их фреймворку. Это облегчает и ускоряет разработку.

**Независимость от базы данных.** Hibernate может работать с любой базой и не имеет жесткой привязки к какой-то конкретной базе или [СУБД](https://blog.skillfactory.ru/glossary/subd/). Благодаря этому он гибкий, его можно использовать в связке с другими технологиями. Язык запросов у него тоже свой, независимый от СУБД, хотя Hibernate поддерживает и «чистый» [SQL](https://blog.skillfactory.ru/glossary/sql/).

**Объектно-ориентированный подход.** Hibernate реализует парадигму объектно-ориентированного программирования, которая очень распространена и хорошо знакома разработчикам. Поэтому работать с ним относительно просто, если вы уже знаете основы: не приходится постоянно отвлекаться на совершенно другую логику работы с базами данных. Можно реализовать все управление на ООП — этому способствует и наличие собственного SQL-подобного объектно-ориентированного языка запросов.

### Недостатки Hibernate Framework

**Сложность в освоении.** Эта проблема актуальна в основном для новичков. Для работы с фреймворком нужно понимать теорию реляционных БД. Понадобится знать, что такое транзакция, по каким принципам работают базы данных, как с ними взаимодействовать и многое другое. Естественно, надо знать Java: осваивать фреймворки советуют после изучения основных принципов «чистого» языка.

**Проблемы с производительностью.** Несмотря на возможности, которые дает «ленивая загрузка», спецификацию JPA и в частности Hibernate часто критикуют за низкую производительность. Есть мнение, которое частично подкрепляется на практике, что такой тип взаимодействия с базой замедляет и утяжеляет код.

**Непредсказуемость кода.** Это еще один частый пункт критики JPA и Hibernate как ее реализации. Спецификация построена на объектно-ориентированной модели программирования, но не полностью соблюдает ее принципы. Это приводит к тому, что в коде могут появиться побочные эффекты — так называется явление, когда во время выполнения программы какие-то значения неявно изменяются. Побочные эффекты могут влиять на правильность работы программы, так что их надо избегать. А при использовании JPA избежать их сложно, и к Hibernate это тоже относится.

**Сложности с кэшированием.** В целом информацию в Hibernate можно кэшировать, то есть сохранять в специальном участке памяти, очень быстром и компактном. Это один из плюсов фреймворка — кэширование важно для производительности. Оно нужно для быстрого доступа к важным данным.

На практике кэширование самих сущностей JPA работает своеобразно:

-   изменяемые сущности кэшировать не получится — инструментарий не дает возможности синхронизировать изменения с кэшем;
-   неизменяемые сущности кэшировать можно, но не полноценно. Сущность загружается из базы через транзакцию — последовательность запросов в БД. Когда транзакция закрывается, на кэшированную сущность становится нельзя сослаться — только получить из нее данные.


## ORM
**ORM** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Object-Relational Mapping, [рус.](https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Русский язык") объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает [базы данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Базы данных") с концепциями [объектно-ориентированных языков программирования](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Объектно-ориентированное программирование"), создавая «виртуальную [объектную базу](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Объектно-ориентированная база данных") данных». Существуют как [проприетарные](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BF%D1%80%D0%B8%D0%B5%D1%82%D0%B0%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Проприетарное программное обеспечение"), так и [свободные](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Свободное программное обеспечение") реализации этой технологии.

Необходимо обеспечить работу с данными в терминах классов, а не таблиц данных, и, напротив, преобразовать термины и данные классов в данные, пригодные для хранения в СУБД. Необходимо также обеспечить интерфейс для [CRUD](https://ru.wikipedia.org/wiki/CRUD "CRUD")-операций над данными. В общем, необходимо избавиться от необходимости писать SQL-код для взаимодействия с СУБД[[1]](https://ru.wikipedia.org/wiki/ORM#cite_note-_c1715ccbfc119943-1)
## Как помогает в программировании
Hibernate реализует ряд фичь которые значительно упрощают работу разработчика. — Одной из таких фичь является то, что hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк). — Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия. — Сам генерирует таблицы в базу данных.
## Какие преимущества Hibernate над JDBC?

Hibernate имеет ряд преимуществ перед JDBC API:

1.  Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать.
2.  Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API.
3.  Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить вне транзакции. При использовании JDBC API для управления транзакциями нужно явно использовать commit и rollback.
4.  JDBC API throws SQLException, которое относится к проверяемым исключениям, а значит необходимо постоянно писать множество блоков try-catch. В большинстве случаев это не нужно для каждого вызова JDBC и используется для управления транзакциями. Hibernate оборачивает исключения JDBC через непроверяемые JDBCException или HibernateException, а значит нет необходимости проверять их в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки try-catch.
5.  Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык запросов, чем SQL в JDBC.
6.  Hibernate поддерживает кэширование, а запросы JDBC — нет, что может понизить производительность.
7.  Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.
8.  Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

## Что такое конфигурационный файл Hibernate?

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.
## Что такое Hibernate mapping file?

Файл отображения (mapping file) используется для связи entity бинов и колонок в таблице базы данных. В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен (например при использовании сторонних библиотек).

## Transient, Persistent, Detached (Состояния entity)
1.  **Transient**: состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью. Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода save(), persist() или saveOrUpdate(). Объект персистентности может перейти в transient состоянии после вызова метода delete().
2.  **Persistent**: когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent.
3.  **Detached**: если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().

## Транзакция
**Транза́кция** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") transaction, от [лат.](https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D1%82%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Латинский язык") transactio — соглашение, договор) — минимальная логически осмысленная операция, которая имеет смысл и может быть совершена только полностью.

### В Hibernate
Hibernate умеет работать с двумя видами транзакций:

-   JDBC
-   JTA

JDBC-транзакция, – это фактически транзакция базы данных. Она привязана к работе с базой данных, к JDBC-соединению. И следит за тем, чтобы действия при работе с базой данных выполнялись как надо: или все или ничего.

JTA – транзакция – это транзакция уровня приложения. Она не привязана ни к какой базе данных. Ее задача следить, чтобы некоторые действия выполнялись: или все, или ничего.
## Стратегии загрузки коллекций
Всего в хибернейте существует 4 способа управлять загрузкой дочерних коллекций:

1.  SELECT
2.  JOIN
3.  SUBSELECT
4.  BATCH

### Select

Это самая распространенная стратегия загружки дочерних данных, именно ее используется хибернейт по умолчанию, если стратегия загрузки не указана явно. Она выполняет загрузку дочерней коллекций с помощью отдельного select запроса.

###### Достоинства

1.  Рабочая стратегия без подводных камней для данных небольшого объема.

###### Недостатки

1.  Проблема N+1 запроса, которая при больших объемах данных может существенно снизить скорость.

### JOIN

Чтобы избавиться от проблемы N+1 запроса, можно использовать стратегию JOIN, которая объединяет родительскую и дочернюю таблицы с помощью оператора join.
###### Особенности использования

-   Объявление данной стратегии применит режим джойнов только для запросов поиска сущностей по id: **session.find(class, id)**.
    
-   Для остальных запросов установленный режим будет игнорироваться (http://stackoverflow.com/questions/36796798/why-hibernate-sometimes-ignores-fetchmode-join), поэтому в hql необходимо _явно_ указывать таблицы для джойна (более того, когда хибернейт встречает join в запросе, он игнорирует любую установленную ранее стратегию и забирает данные в режиме JOIN).
    
-   Работа стратегия Join подразумевает энергичную загрузку данных, поэтому даже если указать ленивую _(FetchType = LAZY)_, параметр будет проигнорирован и данные загрузятся сразу же.
    

###### Недостатки стратегии

1.  **Большой паразитный размер ответа БД.** Основным недостатком данной стратегии является особенность работы оператора join, который при соединении второй таблицы выполняет декартово произведение строк. Это означает, что если у нас есть 2 книги по 3 комментария, результат выборки будет содержать 6 строк. Что влечет за собой существенное увеличение размера ответа БД.
    
2.  **Отсутствие пейджинации в sql-запросе.** Исходя из первого недостатка, в выборке будут дублирующиеся книги, что не позволяет использовать пейджинацию на уровне запросов. Поэтому при указании _setMaxResults(), setFirstResult()_, хибернейт сначала скачает две таблицы полностью (book и comments), а только потом самостоятельно отделит дубли и применит пейджинацию. Если представить, что в базе содержится 50 000 книг, то запрос 10 книг с пейджинацией, приведет к скачиванию всей таблицы book, то есть 50 000 книг!

### Batch

Один из способов получения данных без недостатков стратегии JOIN - использование режима SELECT с пакетной выборкой зависимых коллекций. Это способ отличается от стратегии SELECT только тем, что зависимые коллекции загружаются не одиночными запросами, а пакетно. Где размером пакета управляет аннотация **@BatchSize**

Данная стратегия позволяет использовать пейджинацию, т.к. первым выполняется запрос на получение родительских объектов, где возможно применение интервалов к выборке. А затем, для полученных объектов, запрашиваются дочерние коллекции.

###### Достоинства

1.  Решает проблему N+1 не создавая других: нет проблемы Декартова произведения, работает пейджинация в самом sql запросе.

###### Недостатки

1.  Необходимо вручную устанавливать размер пакета. Не всегда ясно чему он должен быть равен. Это скорее не недостаток, а небольшое неудобство.

### Subselect

Как в предыдущем, для данного режима ленивая загрузка игнорируется. Всего формируется 2 запроса, первый для получения книг, второй - для получения комментариев с подзапросом.
###### Недостатки

1.  Отсутствие пейджинации. Хотя стратегии Subselect ничто не мешает использовать в подзапросе пейджинацию из родительского запроса, в хибернейте это не работает. Баг заведен в 2007 году https://hibernate.atlassian.net/browse/HHH-2666 и не исправлен даже в версии 5.2.3.Final. Более подробно можно почитать здесь http://www.christophbrill.de/de_DE/hibernate-fetch-subselect-performance/

###### Достоинства

1.  Всего 2 запроса к БД.
2.  Нет проблемы Декартова произведения.

### Динамический выбор стратегии загрузки

Установленный один раз режим запросов будет распространяться на все существующие и новые запросы. На практике же часто необходима использовать в разных запросах различные стратегии загрузки. Небольшую свободу, конечно, предоставляет режим JOIN, позволяя определять коллекции для загрузки прямо в запросах, но в целом удобного выбора стратегий в хибернейте нет.
## Стратегии загрузки обьектов
| HQL      | Hibernate Query Language; |
|----------|---------------------------|
| SQL      | native SQL query;         |
| Criteria | Hibernate Criteria API.   |


## ID generator-классы в Hibernate
### Введение. Зачем нам вообще нужны ID в JPA сущностях?

Спецификация JPA гласит, что сущность – это обычный Java класс, который удовлетворяет следующим условиям: 

1.  Должен быть помечен аннотацией `@Entity`.
    
2.  В классе должен быть конструктор без аргументов.
    
3.  Класс не должен быть закрытым (final).
    
4.  И обязательно должно быть поле (или несколько полей) ID с соответствующей аннотацией.
    

Как видим, поле ID – обязательное. Но почему?  

Реляционные базы данных не требуют обязательного определения первичного (и уникального) ключа для таблиц. Да и при доступе к базе через JDBC от нас не требуется знать, есть ли на таблицах первичные ключи или нет. Все, что мы делаем при работе через JDBC – работаем с БД и использованием SQL – языка запросов для баз данных. Чтобы получить данные, разработчик запускает `SELECT` запрос, которые возвращает некоторый набор значений. Чтобы сохранить данные, нужно написать и запустить оператор `INSERT` и т. д. Важный момент здесь: на таком уровне работы с базой данных нет прямой связи между записями в таблицах в базе данных и объектами в приложении. Преобразование выбранных данных в объекты выполняется, как правило, вручную и является частью бизнес-логики приложения. 

JPA проповедует другую философию: есть сущности – Java классы, экземпляры которых жестко привязаны к записям в таблицах БД. Ровно поэтому спецификация требует, чтобы разработчики указывали ключевые поля. Это нужно, чтобы делать однозначное сопоставление между объектом в приложении и записью в таблице. Такой подход помогает скрыть низкоуровневые операции с базой данных. Разработчик выбирает из базы объекты, модифицирует их и сохраняет, при этом ORM фреймворк точно знает, с какой конкретно записью БД происходит работа. В итоге это должно помогать сконцентрироваться разработчикам на реализации бизнес-логики, в то время как ORM фреймворк берет на себя все рутинные операции. И, как видно, наличие уникального идентификатора объекта – неотъемлемая часть этого процесса. 

_Замечание_: В общем-то, поле ID не должно отображаться на первичный ключ таблицы. Нужно делать отображение на какой-то столбец (столбцы), который уникально идентифицирует строку. Но дальше в статье термины «ID» и «первичный ключ» будут употребляться как взаимозаменяемые. 

### Типы ID - что у нас есть?

Итак, нам нужно определить ID для нашей сущности. Что у нас есть в наличии?

Первое: ID может быть «простым» и «составным». «Простой» ID – это одно поле в сущности, а «составной» - это отдельный класс с набором полей для идентификации экземпляра сущности.

В подавляющем большинстве случаев мы используем простые ID для наших сущностей. Их можно генерировать автоматом (суррогатные ID) и это самый распространенный способ присвоения значений для первичного ключа. Генерацией может заниматься сервер БД или это может происходить в приложении. У этих подходов есть как плюсы, так и минусы.

В этой статье мы сфокусируемся на ID, генерируемых в БД. Для простоты изложения мы будем использовать самую распространенную имплементацию JPA – Hibernate – во всех примерах. Другие JPA имплементации будут упомянуты явно, при необходимости.

### Генерация ID – зачем весь этот шум?

Генерация ID обычно случается только однажды – во время сохранения сущности в базу данных. Давайте предположим, что у нас есть приложение, которое работает эксклюзивно с БД и не создает большого количества данных, скажем, не больше 100 записей в секунду. В этом случае, мы, наверное, можем использовать любой способ генерации ID. Приложение для работы со списком названий стран, наверное, будет хорошим примером, новые страны в мире не так часто появляются. А что насчет сохранения данных с электросчетчиков? Если у нас есть 100 счетчиков, которые посылают нам данные каждый час, то можем смело сохранять один замер раз в 36 секунд. Небольшая нагрузка, очевидно. А если взять 1000 счетчиков? Десять тысяч? И сохранять с них данные каждые 10 минут? Сколько будет стоить бизнесу поменять способ генерации ID?

На практике, приложения имеют тенденции к росту, как и бизнес. Собственно, поэтому выбор стратегии генерации первичных ключей – важная тема, которая позволит вам избежать болезненных миграций в будущем. Далее будет употребляться термин «производительность», и, хотя мы не Facebook и не Twitter, и не сохраняем миллионы сущностей в секунду, но это не значит, что нам не нужно думать о выборе стратегии генерации ID заранее. Это позволит избежать некоторых неудобство в будущем.

### Как работает генерация ID по умолчанию

Самый простой способ определить генерируемый ID для JPA сущности – поставить аннотации `@Id` и `@GeneratedValue` над нужным полем. Нам даже не нужно выставлять никакие параметры генерации, значения по умолчанию отработают нормально и в поле будет присваиваться уникальное значение каждый раз при сохранении.

```
@Table(name = "pet")
@Entity 
public class Pet {     
  @Id     
  @GeneratedValue     
  @Column(name = "id", nullable = false)     
  private Long id; 

}
```

В мире есть два типа значений по умолчанию: те, которые не надо трогать и те, которые обязательно надо поменять. Значения по умолчанию обычно выставляются так, чтобы с ними все работало. Но так ли они хороши в нашем случае? Давайте посмотрим на значения параметров аннотации `@GeneratedValue`:

```
public @interface GeneratedValue {
    GenerationType strategy() default AUTO;
  
    String generator() default "";
}
```

Что у нас тут? Стратегия генерации  - `AUTO`. Это означает, что JPA провайдер решает, как генерировать уникальные ID для нашей сущности. И сразу возникает вопрос: а достаточно ли хорош этот способ? Давайте сначала разберемся, какие вообще есть стратегии генерации.

Стандарт JPA, помимо `AUTO`, определяет ещё три стратегии:

-   `IDENTITY` - используется встроенный в БД тип данных столбца -identity - для генерации значения первичного ключа.
    
-   `SEQUENCE` - используется последовательность – специальный объект БД для генерации уникальных значений.
    
-   `TABLE` - для генерации уникального значения используется отдельная таблица, которая эмулирует последовательность. Когда требуется новое значение, JPA провайдер блокирует строку таблицы, обновляет хранящееся там значение и возвращает его обратно в приложение. Эта стратегия – наихудшая по производительности и ее желательно избегать. Больше про этот подход можно узнать [из документации](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-table), здесь мы его рассматривать не будем.
    

Как написано в [руководстве разработчика](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-auto), если мы выставляем тип ID, отличный от UUID (Long, Integer и т. д.) и используем стратегию генерации `AUTO`, то Hibernate (начиная с версии 5.0) сделает следующее:

-   Попробует использовать стратегию `SEQUENCE`.
    
-   Если БД не поддерживает последовательности (например, MySQL), то будет использоваться стратегия `TABLE` (или `IDENTITY`, в версии до 5.0).
    

Почему Hibernate сначала пытается использовать `SEQUENCE`? Основная причина – производительность. Как уже говорилось, `TABLE` обладает наихудшей производительностью (хотя самой большой совместимостью с СУБД). [Есть статья](https://amrutprabhu.medium.com/spring-boot-jpa-bulk-insert-performance-by-100-times-14ec10fa682b), в которой автор сравнивает разные стратегии генерации ID, сохраняя 10 000 сущностей в БД. Ему удалось добиться уменьшения времени со 185 секунд до 4.3, когда он начал использовать `SEQUENCE` вместо `IDENTITY` и включил некоторые оптимизации (такие, как пакетная обработка данных). Таким образом, обе стратегии: `IDENTITY` и `TABLE` будут работать, но производительность пострадает.

Самое интересное, что даже `SEQUENCE`в конфигурации по умолчанию не будет работать быстро, производительность будет близка к `IDENTITY`. Это происходит из-за того, что используется всего одна последовательность, а ее параметры не позволяют использовать кэширование ID средствами Hibernate. Мы подробнее поговорим об этом чуть позже.

**Итого**: если для генерации ID оставить значения по умолчанию, то, скорее всего, это негативно повлияет на производительность приложения. Для «боевого» применения будет лучше более тонко настроить стратегии генерации.

### Sequence: как правильно готовить?

Стратегия `SEQUENCE` использует специализированный объект БД – последовательность (sequence) для генерации уникального значения ID сущности и это значение присваивается до сохранения (и это важно!) сущности в БД. Такой алгоритм обеспечивает возможность пакетного (batch) сохранения данных. Это происходит за счет того, что приложению не надо перезапрашивать из базы значение ID после сохранения каждой записи, как это происходит в случае использования identity столбцов, триггеров и т. д.

#### А если ничего не настраивать?

Чтобы использовать последовательность для генерации первичного ключа, все, что нам нужно – написать код, представленный ниже. По факту это то, что сделает стратегия `AUTO`, если наша БД поддерживает последовательности.

```
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE)
@Column(name = "id", nullable = false)
private Long id;
```

Если мы включим автоматическое создание схемы БД и показ выполняемых запросов в Hibernate, то мы увидим что-то такое:

```
create sequence hibernate_sequence start 1 increment 1;
```

JPA провайдер будет использовать только эту последовательность для всех операторов `INSERT`, сгенерированных для сущностей с настройками стратегии `SEQUENCE` по умолчанию. И это может привести к неприятным последствиям.

Во-первых, значения в последовательности могут просто  
закончиться. В большинстве БД максимальное количество значений  
последовательности – 2^63-1, исчерпать такое количество значений, конечно,  
сложновато. Но все возможно, если ваше приложение генерирует огромное  
количество данных; например, у вас огромное количество IoT устройств, постоянно  
присылающих замеры или баннерная сеть, которая генерирует миллионы  
кликов-событий каждый день.

2^63-1 – большое число

Во-вторых, будет страдать производительность. По умолчанию, мы увеличиваем значение последовательности на 1 и это не позволяет использовать оптимизацию выборки значений в Hibernate. Для каждого сохраняемого объекта ORM вынужден делать запрос в базу. Например, если мы попробуем сохранить пару объектов, то в логах Hibernate увидим примерно следующее:

```
select nextval ('hibernate_sequence')
insert into pet (name, id) values (?, ?)
select nextval ('hibernate_sequence')
insert into pet (name, id) values (?, ?)
```

Можно заметить, что у нас появляются накладные расходы: для каждой операцию вставки мы делаем дополнительную выборку из БД. И это, очевидно, будет влиять на скорость вставки данных в базу.

**Итого**: Значения по умолчанию для стратегии `SEQUENCE` неплохо работают для приложений, которые не генерируют большой объем данных. Если нам нужно больше производительности, и меньше проблем с единственной последовательностью, то нужно менять параметры генерации ID.

#### Что мы можем настроить?

Начнем с простого: назначим отдельную последовательность для генерации ID для сущности.

```
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pet_seq")
@Column(name = "id", nullable = false)
private Long id;
```

Если опять заглянем в логи Hibernate, увидим следующий SQL:

```
create sequence pet_seq start 1 increment 50
```

Если не используется последовательность по умолчанию, Hibernate «кэширует» значения ID при выборке из последовательности. Идея в том, чтобы при одном запросе «захватить» какой-то диапазон значений и потом назначать значения ID из этого диапазона. По умолчанию, Hibernate захватывает 50 значений.

Оптимизация работает так:

-   **Шаг 1**: Hibernate выполняет один `SELECT` из последовательности и получает текущее значение.
    
-   **Шаг 2**: Если это значение равно начальному значению, с которым создавалась последовательность, то Hibernate выбирает следующее значение ID, и назначает это значение верхней границей диапазона. А значение, выбранное на шаге 1 – нижней границей. В противном случае переходим к шагу 4.
    
-   **Шаг 3**: Вставляем данные, назначаем ID, начиная с `нижней`границы до `верхней`, пока не закончатся значения.
    
-   **Шаг 4**: Выбираем следующее значение ID из последовательности (оно больше, чем начальное). В этом случае Hibernate вычисляет доступный диапазон, используя параметр `allocationSize`. `Нижняя` граница = `ID – allocationSize+1`, `верхняя` = `ID`. Дальше переходим к шагу 3.
    

Итого, мы делаем только два запроса `SELECT` чтобы сохранить первые 50 сущностей. Для следующих 50-ти нам нужно будет сделать только один дополнительный запрос. Если опять заглянем в логи Hibernate, то увидим:

```
select nextval ('pet_seq'); //получаем 1 – начальное значение, нужно ещё одно
select nextval ('pet_seq'); //получаем 51 – верхнюю границу диапазона
insert into pet (name, id) values (?, ?);// id=1
insert into pet (name, id) values (?, ?);//id=2
//сохраняем остальные 48 сущностей
select nextval ('pet_seq'); //выбираем 101, это верхняя граница, нижняя равна 101 – 50+1 = 52
insert into pet (name, id) values (?, ?);//id=52
//и т. д. 
```

В этом подходе есть один недостаток: если мы закрываем сессию с базой данных (приложение перезапустилось или мы пересоздаем entity manager), то неиспользованные значения будут потеряны навсегда. Хороший пример такого короткоживущего приложения – serverless lambda. Если сохраняем только одну сущность за запуск, то остальные 49 значений теряем. Это может привести к более быстрому окончанию значений в последовательности, поэтому для коротких сессий нужно уменьшать шаг последовательности, чтобы не терять много ID.

Для настройки параметров генерации ID, например, для уменьшения шага последовательности, используется аннотация `@SequenceGenerator`. Эта аннотация позволяет нам задать необходимые параметры для генерации последовательности в БД: название, начальное значение и шаг. Код ниже показывает, как создать последовательность с шагом 20.

```
@Id
@SequenceGenerator(name = "pet_seq", 
        sequenceName = "pet_sequence", 
        initialValue = 1, allocationSize = 20)
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pet_seq")
@Column(name = "id", nullable = false)
private Long id;
```

Hibernate сгенерирует и выполнит вот такой вот SQL, если последовательности нет в БД:

```
create sequence pet_sequence start 1 increment 20
```

При определении генератора таким способом нужно помнить следующее: если мы хотим использовать существующую последовательность, то параметр `allocationSize` должен в точности совпадать с шагом последовательности. Если в Hibernate включена валидация схемы, то приложение не запустится, если значения не совпадают.

Отключить валидацию схемы можно, установив параметр `hibernate.id.sequence.increment_size_mismatch_strategy` в значение `LOG` или `FIX`.

Для значения `LOG`Hibernate проигнорирует несовпадение значений параметров генератора и последовательности, и это может привести к нарушениям уникальности при генерации ID. Например, если для генератора значение `allocationSize` равно 20, а в последовательности параметр `increment` равен 1, то мы получим что-то такое:

```
select nextval ('pet_seq'); // выбираем 1 начальное значение, нужно выбрать следующее
select nextval ('pet_seq'); //выбираем 2 – конечное значение диапазона
insert into pet (name, id) values (?, ?);// id=1
insert into pet (name, id) values (?, ?);//id=2
//Закончился диапазон, выбираем следующее
select nextval ('pet_seq'); //выбираем 3 конечное значение, считаем 3 – 20 + 1 = -16 - начальное
insert into pet (name, id) values (?, ?);//id=-16
insert into pet (name, id) values (?, ?);//id=-15
//Новая сессия
select nextval ('pet_seq'); //выбираем 4 – конечное значение, считаем 4 – 20 + 1 = -15 - начальное
insert into pet (name, id) values (?, ?);//id=-15 нарушение уникальности
```

Если поставим значение параметра - `FIX`, то в этом случае Hibernate автоматически поменяет значение `allocationSize` и выставит его равным шагу последовательности, т.е. для нашего случая выше будет установлена 1.

Еще одна штука, которую можно использовать при определении `@SequenceGenerator` - можно переиспользовать одну последовательность для разных сущностей. Нужно просто указать одинаковые значения в `sequenceName` для разных генераторов.

```
//ID Definition for ‘Pet’ entity
@Id
@SequenceGenerator(name = "pet_seq", sequenceName = "common_sequence")
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pet_seq")
@Column(name = "id", nullable = false)
private Long id;

//ID Definition for ‘Owner’ entity
@Id
@SequenceGenerator(name = "owner_seq", sequenceName = " common_sequence ")
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "owner_seq")
@Column(name = "id", nullable = false)
private Long id;
```

**Итого**: явное задание генераторов позволяет нам:

1.  Пользоваться оптимизацией выборки ID для лучшей производительности.
    
2.  Настраивать размер пула ID в зависимости от количества вставляемых данных.
    
3.  Использовать одну и ту же последовательность для ID разных сущностей.
    

И, похоже, что стратегия `SEQUENCE` практически идеальна. Но и на солнце бывают пятна…

#### Несколько клиентов для одной базы – это проблема?

Несмотря на то, что `SEQUENCE` использует БД для генерации ID, но присваивание значений производится в коде приложения. С одной стороны, это дает нам оптимизации и пакетные вставки данных, но с другой стороны другие приложения, которые используют ту же самую БД, даже не подозревают, что им нужно использовать определенную последовательность для генерации значений первичных ключей.

Это может привести к тому, что другие приложения назначают ID в соответствии со своими соображениями и полностью игнорируют последовательность. В итоге, мы можем запросто получить нарушения уникальности первичного ключа, как в нашем приложении, так и в соседних.

**Итого**: Стратегия `SEQUENCE` для генерации ID может не очень хорошо себя показывать, если несколько клиентов работают с одной и той же базой. В таких случаях единственно надежный способ – генерация ID при вставке в базу. И здесь гораздо лучше работает стратегия `IDENTITY`.

### Identity: за и против

`IDENTITY` - это, наверное, самая распространенная стратегия среди разработчиков, использующих MySQL. Но, кроме MySQL, многие СУБД поддерживают аналогичный механизм: специальный тип данных столбца таблицы, которые автоматом назначает уникальные значения вставляемым строкам. Так что эту стратегию можно видеть в большом количестве приложений. Иногда разработчики руководствуются принципом «работало на предыдущих проектах» при выборе этой стратегии в новых приложениях. Мало кто хочет менять привычки, которые не подводили. Когда мы определяем стратегию `IDENTITY` для генерации значений ID, мы получаем надежный способ обеспечения уникальности первичного ключа, (почти) не зависящий от клиентов БД.

```
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id", nullable = false)
private Long id;
```

Для каждого оператора `INSERT`, база данных автоматически генерирует уникальное значение ID поля. Хотя в некоторых СУБД, если мы указываем значение ID явно, то оно не будет перезаписано, так что, в теории, несколько клиентов могут получить нарушение уникальности, если они назначают значения ID явно.

Поведение стратегии `IDENTITY` схоже с `SEQUENCE`, если мы определим шаг последовательности равным 1. Но есть одно значительное различие. Нужно помнить, что для назначения ID данные должны быть физически вставлены в таблицу. И только после того, как оператор `INSERT` выполнился, мы сможем узнать значение ID. Следовательно, JPA провайдер должен каким-то образом вернуть это значение обратно в приложение после сохранения объекта в БД.

Возникает вопрос: а как ORM выбирает значение ID после вставки? Если JDBC драйвер БД поддерживает JDBC v.3 (а современные БД поддерживают), это делается автоматически. JPA провайдер неявно вызывает метод `Statement.getGeneratedValues()`, который и возвращает сгенерированное значение. Под капотом при вставке данных вызывается примерно такой SQL:

```
insert into pet (name) values (‘Buddy’) RETURNING *
```

А что будет, если у нас старый драйвер? В этом случае JPA провайдер может попытаться выполнить дополнительный запрос самостоятельно (а зачастую нам придется делать это вручную), чтобы на основании сохраненных данных получить значение ID. Ну вот, например, как это может выглядеть для старой версии PostgreSQL. В PostgreSQL тип `IDENTITY` эмулируется через последовательность, но принцип будет примерно таким же в случае использования других СУБД:

```
insert into pet (name) values (?)
select currval('pet_id_seq')
insert into pet (name) values (?)
select currval('pet_id_seq')
```

Использование `IDENTITY` не позволяет использовать пакетную вставку данных. Поскольку ORM должен получать ID после каждой вставки (вне зависимости от версии JDBC драйвера), то он (ORM) разбивает сохранение массива объектов на отдельные вызовы `INSERT`. Мы просто не можем себе позволить отправить список объектов на сохранение в БД и получить массив ID взамен. БД не гарантирует порядок вставки для пакетных операций, так что ID могут быть не в том порядке, в котором был наш список объектов. Следовательно, нельзя будет надежно сопоставить значение ключа с объектом, а это есть критическая часть работы JPA. Так что единственный выход – сохранять по одному объекту.

**Итого**: стратегия `IDENTITY` проста в использовании и позволяет надежно получать уникальные ID вне зависимости от клиентов, использующих БД.

С другой стороны, данная стратегия не позволяет использовать пакетное сохранение данных, а производительность обычных операций вставки также может быть чуть ниже, чем при использовании последовательностей. Следовательно, рекомендуется использовать `IDENTITY` для случаев, когда мы сохраняем небольшой объем данных или когда есть риск, что одна и та же база данных используется несколькими приложениями, которые могут туда писать данные.

### Подведем итоги: Identity vs Sequence vs остальное

Итак, какую же стратегию выбрать для генерации ID для наших JPA сущностей? Вот пара рекомендаций.

В первую очередь рассмотрите `SEQUENCE`. Эта стратегия обеспечивает самую высокую производительность в сравнении с остальными. Также нужно обратить внимание на следующее:

1.  Хорошей практикой считается задание отдельной последовательности для каждой сущности. Нужно избегать использования значений по умолчанию в настройках.
    
2.  Используйте `@SequenceGenerator` для тонкой настройки генерации значений ID и параметров генерируемой последовательности.
    
3.  Шаг последовательности задавайте в соответствии с нагрузкой приложения.
    

Использование `IDENTITY` оправдано, если:

1.  СУБД не поддерживает последовательности.
    
2.  Создается небольшой объем данных.
    
3.  В базу данных могут писать другие приложения.
    

По возможности старайтесь не использовать стратегии `TABLE` and `AUTO`, с ними будет наихудшая производительность.
## Ключевые интерфейсы hibernate
1.  **SessionFactory (org.hibernate.SessionFactory)** — неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных. Необходимо инициализировать SessionFactory всего один раз. Экземпляр SessionFactory используется для получения объектов Session, которые используются для операций с базами данных.
2.  **Session (org.hibernate.Session)** — однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных. Он оборачивает JDBC java.sql.Connection и работает как фабрика для org.hibernate.Transaction. Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования. Экземпляр Session является интерфейсом между кодом в java приложении и hibernate framework и предоставляет методы для операций CRUD.
3.  **Transaction (org.hibernate.Transaction)** — однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать несколько org.hibernate.Transaction в определенных случаях.
Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate:
— Session interface;
— SessionFactory interface; 
— Configuration interface; 
— Transaction interface; 
— Query and Criteria interfaces.
## Важные аннотации
1.  **javax.persistence.Entity**: используется для указания класса как entity bean.
2.  **javax.persistence.Table**: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.
3.  **javax.persistence.Access**: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их необходимо задать для нужного свойства.
4.  **javax.persistence.Id**: определяет primary key в entity bean.
5.  **javax.persistence.EmbeddedId**: используется для определения составного ключа в бине.
6.  **javax.persistence.Column**: определяет имя колонки из таблицы в базе данных.
7.  **javax.persistence.GeneratedValue**: задает стратегию создания основных ключей. Используется в сочетании с javax.persistence.GenerationType enum.
8.  **javax.persistence.OneToOne**: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany.
9.  **org.hibernate.annotations.Cascade**: определяет каскадную связь между двумя entity бинами. Используется в связке с org.hibernate.annotations.CascadeType.
10.  **javax.persistence.PrimaryKeyJoinColumn**: определяет внешний ключ для свойства. Используется вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.
| @Entity                             | Определение класса как сущность entity bean               |
|-------------------------------------|-----------------------------------------------------------|
| @Table, @Column                     | Определение таблицы в БД и наименования колонки в таблице |
| @Id                                 | Поле Primary Key в сущности entity bean                   |
| @GeneratedValue                     | Определение стратегии создания основных ключей            |
| @SequenceGenerator                  | Определение генератора последовательности                 |
| @OneToMany, @ManyToOne, @ManyToMany | Определение связи между сущностными бинами                |

## Какая роль интерфейса Session в Hibernate? 
Session — это основной интерфейс, который отвечает за связь с базой данных. Так же, он помогает создавать объекты запросов для получение персистентных объектов. (персистентный объект — объект который уже находится в базе данных; объект запроса — объект который получается когда мы получаем результат запроса в базу данных, именно с ним работает приложение). Обьект Session можно получить из SessionFactory : Session session = sessionFactory.openSession(); Роль интерфейса Session: — является оберткой для jdbc подключения к базе данных; (https://ru.wikipedia.org/wiki/Java_Database_Connectiv..) — является фабрикой для транзакций (согласно официальной документации transaction — аllows the application to define units of work, что , по сути, означает что транзакция определяет границы операций связанных с базой данных). — является хранителем обязательного кэша первого уровня.

## Какая роль интерфейса SessionFactory в Hibernate?
Именно из объекта SessionFactory мы получаем объекты типа Session. На все приложение существует только одна SessionFactory и она инициализируеться вместе со стартом приложения. SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях. Обьект SessionFactory можно получить следующим обращением: SessionFactory sessionFactory = configuration.buildSessionFactory();

## Какая разница в работе методов load(); и get();? 
Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект. Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.
## Что такое Lazy fetching(изъятие) в Hibernate? 
Тип изьятия Lazy, в Hibernate, связан с листовыми(дочерними) сущностями и определяют политику совместного изъятия, если идет запрос на изъятие сущности родителя. Простой пример: Есть сущность Дом. Он хранит информацию о своем номере, улице, количество квартир и информацию о семьях которые живут в квартирах, эти семьи формируют дочернюю сущность относительно сущности Дом. Когда мы запрашиваем информацию о Доме, нам может быть совершенно ненужным знать информацию семьях которые в нем проживают, тут нам на помощь приходит lazy(ленивое) изъятие(fetching) которая позволяет сконфигурировать сущность Дом, чтобы информацию о семьях подавалась только по востребованию, это значительно облачает запрос и ускоряет работу приложения.
## Типы коллекций
Какие типы коллекций представлены в Hibernate? Bag, Set, List, Map, Array. 
### Что собой являет коллекция типа Bag и зачем она используется? 
Своей реализации тип коллекции Bag очень напоминает Set, разница состоит в том, что Bag может хранить повторяющиеся значения. Bag хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в Array, на индекс в List или на key в Map. Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа Bag или Set (коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).

## Типы кэша 
Прежде всего Hibernate cache — это 3 уровня кеширования:  

-   Кеш первого уровня (First-level cache);
-   Кеш второго уровня (Second-level cache);
-   Кеш запросов (Query cache);

  

##### Кеш первого уровня

  
Кеш первого уровня всегда привязан к объекту сессии. Hibernate всегда по умолчанию использует этот кеш и его нельзя отключить. Давайте сразу рассмотрим следующий код:  

```
SharedDoc persistedDoc = (SharedDoc) session.load(SharedDoc.class, docId);
System.out.println(persistedDoc.getName());
user1.setDoc(persistedDoc);

persistedDoc = (SharedDoc) session.load(SharedDoc.class, docId);
System.out.println(persistedDoc.getName());
user2.setDoc(persistedDoc);
```

  
Возможно, Вы ожидаете, что будет выполнено 2 запроса в БД? Это не так. В этом примере будет выполнен 1 запрос в базу, несмотря на то, что делается 2 вызова load(), так как эти вызовы происходят в контексте одной сессии. Во время второй попытки загрузить план с тем же идентификатором будет использован кеш сессии.  
Один важный момент — при использовании метода load() Hibernate не выгружает из БД данные до тех пор пока они не потребуются. Иными словами — в момент, когда осуществляется первый вызов load, мы получаем прокси объект или сами данные в случае, если данные уже были в кеше сессии. Поэтому в коде присутствует getName() чтобы 100% вытянуть данные из БД. Тут также открывается прекрасная возможность для потенциальной оптимизации. В случае прокси объекта мы можем связать два объекта не делая запрос в базу, в отличии от метода get(). При использовании методов save(), update(), saveOrUpdate(), load(), get(), list(), iterate(), scroll() всегда будет задействован кеш первого уровня. Собственно, тут нечего больше добавить.  
  

##### Кеш второго уровня

  
Если кеш первого уровня привязан к объекту сессии, то кеш второго уровня привязан к объекту-фабрике сессий (Session Factory object). Что как бы подразумевает, что видимость этого кеша гораздо шире кеша первого уровня. Пример:  

```
Session session = factory.openSession();
SharedDoc doc = (SharedDoc) session.load(SharedDoc.class, 1L);
System.out.println(doc.getName());
session.close();

session = factory.openSession();
doc = (SharedDoc) session.load(SharedDoc.class, 1L);   
System.out.println(doc.getName());       
session.close();    
```

  
В данном примере будет выполнено 2 запроса в базу, это связано с тем, что по умолчанию кеш второго уровня отключен. Для включения необходимо добавить следующие строки в Вашем конфигурационном файле JPA (persistence.xml):  

```
<property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletonEhCacheProvider"/>
//или  в более старых версиях
//<property name="hibernate.cache.provider_class" value="org.hibernate.cache.EhCacheProvider"/>
<property name="hibernate.cache.use_second_level_cache" value="true"/>
```

  
Обратите внимание на первую строку. На самом деле, хибернейт сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации нашего ORM фреймворка. Из популярных реализаций можна выделить [следующие](http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-cache):  

-   EHCache
-   OSCache
-   SwarmCache
-   JBoss TreeCache

  
Помимо всего этого, вероятней всего, Вам также понадобится отдельно настроить и саму реализацию кеша. В случае с EHCache это нужно сделать в файле [ehcache.xml](http://ehcache.org/ehcache.xml). Ну и в завершение еще нужно указать самому хибернейту, что именно кешировать. К счастью, это очень легко можно сделать с помощью аннотаций, например так:  

```
@Entity
@Table(name = "shared_doc")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc{
    private Set<User> users;
}
```

  
Только после всех этих манипуляций кеш второго уровня будет включен и в примере выше будет выполнен только 1 запрос в базу.  
Еще одна важная деталь про кеш второго уровня про которую стоило бы упомянуть — хибернейт не хранит сами объекты Ваших классов. Он хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно можно представить себе это так:  

```
1 -> { "Pupkin", 1, null , {1,2,5} }
```

  
Что есть очень разумно, учитывая [сколько лишней памяти](http://habrahabr.ru/blogs/java/134102/) занимает каждый объект.  
Помимо вышесказанного, следует помнить — зависимости Вашего класса по умолчанию также не кешируются. Например, если рассмотреть класс выше — SharedDoc, то при выборке коллекция users будет доставаться из БД, а не из кеша второго уровня. Если Вы хотите также кешировать и зависимости, то класс должен выглядеть так:  

```
@Entity
@Table(name = "shared_doc")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc{
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<User> users;
}
```

  
  
И последняя деталь — чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.  
  

##### Кеш запросов

  
Перепишем первый пример так:  

```
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");

SharedDoc persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user1.setDoc(persistedDoc);

persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user2.setDoc(persistedDoc);
```

  
Результаты такого рода запросов не сохраняются ни кешом первого, ни второго уровня. Это как раз то место, где можно использовать кеш запросов. Он тоже по умолчанию отключен. Для включения нужно добавить следующую строку в конфигурационный файл:  

```
<property name="hibernate.cache.use_query_cache" value="true"/>
```

  
а также переписать пример выше добавив после создания объекта Query (то же справедливо и для Criteria):  

```
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");
query.setCacheable(true);
```

  
Кеш запросов похож на кеш второго уровня. Но в отличии от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня.  
  

###### Стратегии кеширования

  
Стратегии кеширования определяют поведения кеша в определенных ситуациях. Выделяют четыре группы:  

-   Read-only
-   Read-write
-   Nonstrict-read-write
-   Transactional

  
Подробней можно прочитать [тут](http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-cache-mapping).  
  

###### Cache region

  
Регион или область — это логический разделитель памяти вашего кеша. Для каждого региона можна настроить свою политику кеширования (для EhCache в том же ehcache.xml). Если регион не указан, то используется регион по умолчанию, который имеет полное имя вашего класса для которого применяется кеширование. В коде выглядит так:  

```
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "STATIC_DATA")
```

  
А для кеша запросов так:  

```
query.setCacheRegion("STATIC_DATA");
//или в случае критерии
criteria.setCacheRegion("STATIC_DATA");
```

  
  

###### Что еще нужно знать?

  
Во время разработки приложения, особенно сначала, очень удобно видеть действительно ли кешируются те или иные запросы, для этого нужно указать фабрике сессий следующие свойства:  

```
<property name="hibernate.show_sql" value="true"/>
<property name="hibernate.format_sql" value="true"/>
```

  
В дополнение фабрика сессий также может генерировать и сохранять статистику использования всех объектов, регионов, зависимостей в кеше:  

```
<property name="hibernate.generate_statistics" value="true"/>
<property name="hibernate.cache.use_structured_entries" value="true"/>
```

  
Для этого есть объекты Statistics для фабрики и SessionStatistics для сессии.  
  
Методы сессии:  
flush() — синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии.  
evict() — нужен для удаления объекта из кеша cессии.  
contains() — определяет находится ли объект в кеше сессии или нет.  
clear() — очищает весь кеш.  
  

###### Заключение

  
Вот собственно и все. Естественно, что вне статьи осталось еще не мало разных нюансов, которые возникают походу работы с кешем, а также немало проблем. Но это уже тема для другой статьи.
