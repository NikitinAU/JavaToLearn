Типы автоматического связывания

## IOC and DI
[Инверсия контроля](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) (inversion of control, IoC) – принцип проектирования, по которому контроль над потоком управления передается фреймворку. Управляющий и прикладной код разделяются. При разработке модуля этот подход избавляет от необходимости знать о других модулях программы и деталях их взаимодействия. Такой код становится более переипользуемым и модульным, уменьшает связность.  
  
[Внедрение зависимостей](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8) (Dependency Injection, DI) – одна из реализаций IoC. При взаимодействии с другими модулями, программа оперирует высокоуровневыми абстракциями, тогда как конкретная её реализация поставляется фреймворком.  
  
Стандартная реализация DI – фреймворк инстанциирует все сервисы, и складывает их в IoC-контейнер. При этом специальная сущность, Service Locator, занимается поиском соответствия реализаций абстракциям и их внедрением.  
  
Spring – большой набор различных библиотек. DI реализуется одной из основных библиотек – Spring IoC.  
  
Сущности бизнес-логики в Spring, как и в JavaEE называются beans. Бины объявляются различными способами, корни большинства из них лежат в понятии `Configuration`. В качестве контейнера бинов выступает `ApplicationContext`. Чтобы передать инициализацию зависимости контексту, она помечается аннотацией `@Autowired`.


## Скоупы Бинов
В Spring Framework во всех определениях бизнес-сущностей (bean) явно или неявно присутствует атрибут scope. В Java-конфигурации он передается в аннотации `@Scope`, в xml – в атрибуте `scope` тега `<bean>`.  
  
Атрибут scope – это строка-идентификатор, которая ставит бину в соответствие экземпляр класса `org.springframework.beans.factory.config.Scope`. Скоуп – реализация паттерна «стратегия» для фабрик бинов, инструкция по созданию бизнес-объектов.  
  
В простейшем Spring-приложении всегда существует два сокоупа:  
• _singleton_ – объект создается однажды, при последующих [внедрениях](https://itsobes.ru/JavaSobes/kak-spring-framework-realizuet-pattern-dependency-injection) переиспользуется. Полезен для большинства случаев: различные сервисы, объекты без состояния, [неизменяемые](https://itsobes.ru/JavaSobes/kak-napisat-immutabelnyi-klass) объекты. Стоит заметить, это не класс-синглтон: при объявлении двух бинов одного класса их экземпляров будет два. **Это скоуп по умолчанию**.  
• _prototype_ – при каждом внедрении фабрика бинов создает новый объект. Нужен для изменяемых бинов с состоянием.  
  
Spring Web добавляет 4 дополнительных скоупа, которые делают бин синглтоном в пределах обработки одного сетевого запроса (_request_), клиентской сессии (_session_), контекста сервлета (_application_) и вебсокет-сессии (_websocket_).  
  
Разработчик может добавлять собственные скоупы. Пример реализации одного можно найти в самих исходниках Spring: `SimpleThreadScope`, который делает бин [тред-локальным](https://itsobes.ru/JavaSobes/zachem-ispolzuiutsia-thread-local-peremennye). Для использования его, как и пользовательские скоупы, нужно сначала зарегистрировать в `BeanFactory`.
## Типы автоматического связывания
Существует четыре вида связывания в спринг:

-   autowire **byName,**
-   autowire **byType,**
-   autowire **by constructor,**
-   autowiring by **@Autowired and @Qualifier annotations**

## Часто используемые аннотации
-   **@Controller** – класс фронт контроллера в проекте Spring MVC.
-   **@RequestMapping** – позволяет задать шаблон маппинга URI в методе обработчике контроллера.
-   **@ResponseBody** – позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.
-   **@PathVariable** – задает динамический маппинг значений из URI внутри аргументов метода обработчика.
-   **@Autowired** – используется для автоматического связывания зависимостей в spring beans.
-   **@Qualifier** – используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов).
-   **@Service** – указывает что класс осуществляет сервисные функции.
-   **@Scope** – указывает scope у spring bean.
-   **@Configuration**, **@ComponentScan** и **@Bean** – для java based configurations.
-   AspectJ аннотации для настройки aspects и advices, **@Aspect**, **@Before**, **@After**,**@Around**, **@Pointcut** и др.

## Autowired, Qualifier, Primary
@Autowired

 отвечает в Spring за внедрение зависимостей. Ею можно пометить место внедрения (сеттер, поле или конструктор), и Spring автоматически свяжет нужный бин с этим местом. Используем в нашем коде внедрение зависимости через сеттер с помощью @Autowired

Если есть бин, который вы предпочитаете большую часть времени по сравнению с другими, то используйте `@Primary`, и используйте `@Qualifier` для нестандартных сценариев.

  Если все бины имеют одинаковый приоритет, мы всегда будем использовать `@Qualifier`

Если бин надо выбрать во время исполнения программы, то эти аннотации вам не подойдут. Вам надо в конфигурационном классе создать метод, пометить его аннотацией `@Bean`, и вернуть им требуемый бин.


## Жизненный Цикл Бина
Жизненный цикл любого объекта означает следующее: как и когда он появляется, как он себя ведет во время жизни и как и когда он исчезает. Жизненный цикл бина ровно про это же: «как и когда».

Жизненным циклом управляет спринг-контейнер. В первую очередь после запуска приложения запускается именно он. После этого контейнер по необходимости и в соответствии с запросами создает экземпляры бинов и внедряет необходимые зависимости. И, наконец, бины, связанные с контейнером, уничтожаются когда контейнер завершает свою работу. Поэтому, если мы хотим выполнить какой-то код во время инстанцирования бина или сразу после завершения работы контейнера, один из самых доступных нам вариантов это вынести его в специальные init() и destroy() методы.
![[Pasted image 20230108013230.png]]
1.  Загрузка описаний бинов, создание графа зависимостей(между бинами)
2.  Создание и запуск `BeanFactoryPostProcessors`
3.  Создание бинов
4.  Spring внедряет значения и зависимости в свойства бина
5.  Если бин реализует метод `setBeanName()` из интерфейса NameBeanAware, то ID бина передается в метод
6.  Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через `setBeanFactory()` из этого интерфейса.
7.  Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через `setApplicationContext()`.
8.  `BeanPostProcessor` это специальный интерфейс(о нем ниже), и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод `postProcessBeforeInitialization()`, можно изменить экземпляр бина перед его(бина) инициализацией(установка свойств и т.п.)
9.  Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный `@PostConstruct` или метод `initMethod` из аннотации `@Bean`.
10.  Теперь бин готов к использованию. Его можно получить с помощью метода `ApplicationContext#getBean()`.
11.  После того как контекст будет закрыт(метод `close()` из ApplicationContext), бин уничтожается.
12.  Если в бине есть метод, аннотированный `@PreDestroy`, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод `destroy()`, чтобы очистить ресурсы или убить процессы в приложении. Если в аннотации `@Bean` определен метод `destroyMethod`, то вызовется и он. 
    ![](https://habrastorage.org/r/w1560/webt/kx/at/5e/kxat5ery0dcq_sujzijmiqyutda.png)

Beans – центральный объект заботы Spring Framework. За кулисами фреймворка с ними происходит множество процессов. Во многие из них можно вмешаться, добавив собственную логику в разные этапы жизненного цикла. Через следующие этапы проходит каждый _отдельно взятый_ бин:  
  
**1. Инстанцирование объекта**. Техническое начало жизни бина, работа конструктора его класса;  
  
**2. Установка свойств** из конфигурации бина, [внедрение зависимостей](https://itsobes.ru/JavaSobes/kak-spring-framework-realizuet-pattern-dependency-injection);  
  
**3. Нотификация aware-интерфейсов**. `BeanNameAware`, `BeanFactoryAware` и другие. Мы уже писали о таких интерфейсах [ранее](https://itsobes.ru/JavaSobes/kogda-ispolzuiut-aware-interfeisy-v-spring). Технически, выполняется системными подтипами `BeanPostProcessor`, и совпадает с шагом 4;  
  
**4. Пре-инициализация** – метод `postProcessBeforeInitialization()` интерфейса `BeanPostProcessor`;  
  
**5. Инициализация.** Разные способы применяются в таком порядке:  
**•** Метод бина с аннотацией `@PostConstruct` из стандарта JSR-250 (рекомендуемый способ);  
**•** Метод `afterPropertiesSet()` бина под интерфейсом `InitializingBean`;  
**•** Init-метод. Для отдельного бина его имя устанавливается в параметре определения `initMethod`. В xml-конфигурации можно установить для всех бинов сразу, с помощью `default-init-method`;  
  
**6. Пост-инициализация** – метод `postProcessAfterInitialization()` интерфейса `BeanPostProcessor`.

Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами [финализации](https://itsobes.ru/JavaSobes/finalize) в Java, при жестком выключении (`kill -9`) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:  
  
**1.** Метод с аннотацией `@PreDestroy`;  
**2.** Метод с именем, которое указано в свойстве `destroyMethod` определния бина (или в глобальном `default-destroy-method`);  
**3.** Метод `destroy()` интерфейса `DisposableBean`.  
  
Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них мы поговорим в будущих публикациях.

[![](https://itsobes.ru/assets/JavaSobes/303.jpg)](https://itsobes.ru/assets/JavaSobes/303.jpg)

## Описание @Bean
-   `destroyMethod` — указывает на метод обратного вызова. Метод находится в бине.
-   `initMethod` — указывает на метод обратного вызова. Метод находится в бине.
-   `name` — имя бина. По умолчанию именем бина является имя метода.
-   `value` — алиас для name()



https://habr.com/ru/post/470305/