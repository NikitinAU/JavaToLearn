логи и история

## О системе контроля версий

Что такое «система контроля версий» и почему это важно? Система контроля версий — это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии. Для контроля версий файлов в этой книге в качестве примера будет использоваться исходный код программного обеспечения, хотя на самом деле вы можете использовать контроль версий практически для любых типов файлов.

Если вы графический или web-дизайнер и хотите сохранить каждую версию изображения или макета (скорее всего, захотите), система контроля версий (далее СКВ) — как раз то, что нужно. Она позволяет вернуть файлы к состоянию, в котором они были до изменений, вернуть проект к исходному состоянию, увидеть изменения, увидеть, кто последний менял что-то и вызвал проблему, кто поставил задачу и когда и многое другое. Использование СКВ также значит в целом, что, если вы сломали что-то или потеряли файлы, вы спокойно можете всё исправить. В дополнение ко всему вы получите всё это без каких-либо дополнительных усилий.

### Локальные системы контроля версий

Многие люди в качестве метода контроля версий применяют копирование файлов в отдельный каталог (возможно даже, каталог с отметкой по времени, если они достаточно сообразительны). Данный подход очень распространён из-за его простоты, однако он невероятно сильно подвержен появлению ошибок. Можно легко забыть в каком каталоге вы находитесь и случайно изменить не тот файл или скопировать не те файлы, которые вы хотели.

Для того, чтобы решить эту проблему, программисты давным-давно разработали локальные СКВ с простой базой данных, которая хранит записи о всех изменениях в файлах, осуществляя тем самым контроль ревизий.

![Диаграмма локального контроля версий](https://git-scm.com/book/en/v2/images/local.png)

Рисунок 1. Локальный контроль версий

Одной из популярных СКВ была система RCS, которая и сегодня распространяется со многими компьютерами. [RCS](https://www.gnu.org/software/rcs/) хранит на диске наборы патчей (различий между файлами) в специальном формате, применяя которые она может воссоздавать состояние каждого файла в заданный момент времени.

### Централизованные системы контроля версий

Следующая серьёзная проблема, с которой сталкиваются люди, — это необходимость взаимодействовать с другими разработчиками. Для того, чтобы разобраться с ней, были разработаны централизованные системы контроля версий (ЦСКВ). Такие системы, как CVS, Subversion и Perforce, используют единственный сервер, содержащий все версии файлов, и некоторое количество клиентов, которые получают файлы из этого централизованного хранилища. Применение ЦСКВ являлось стандартом на протяжении многих лет.

![Диаграмма централизованного контроля версий](https://git-scm.com/book/en/v2/images/centralized.png)

Рисунок 2. Централизованный контроль версий

Такой подход имеет множество преимуществ, особенно перед локальными СКВ. Например, все разработчики проекта в определённой степени знают, чем занимается каждый из них. Администраторы имеют полный контроль над тем, кто и что может делать, и гораздо проще администрировать ЦСКВ, чем оперировать локальными базами данных на каждом клиенте.

Несмотря на это, данный подход тоже имеет серьёзные минусы. Самый очевидный минус — это единая точка отказа, представленная централизованным сервером. Если этот сервер выйдет из строя на час, то в течение этого времени никто не сможет использовать контроль версий для сохранения изменений, над которыми работает, а также никто не сможет обмениваться этими изменениями с другими разработчиками. Если жёсткий диск, на котором хранится центральная БД, повреждён, а своевременные бэкапы отсутствуют, вы потеряете всё — всю историю проекта, не считая единичных снимков репозитория, которые сохранились на локальных машинах разработчиков. Локальные СКВ страдают от той же самой проблемы: когда вся история проекта хранится в одном месте, вы рискуете потерять всё.

### Распределённые системы контроля версий

Здесь в игру вступают распределённые системы контроля версий (РСКВ). В РСКВ (таких как Git, Mercurial, Bazaar или Darcs) клиенты не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени) — они полностью копируют репозиторий. В этом случае, если один из серверов, через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. Каждая копия репозитория является полным бэкапом всех данных.

![Диаграмма распределённого контроля версий](https://git-scm.com/book/en/v2/images/distributed.png)

Рисунок 3. Распределённый контроль версий

Более того, многие РСКВ могут одновременно взаимодействовать с несколькими удалёнными репозиториями, благодаря этому вы можете работать с различными группами людей, применяя различные подходы единовременно в рамках одного проекта. Это позволяет применять сразу несколько подходов в разработке, например, иерархические модели, что совершенно невозможно в централизованных системах.

## Что такое Git?

Что же такое Git, если говорить коротко? Очень важно понять эту часть материала, потому что если вы поймёте, что такое Git и основы того, как он работает, тогда, возможно, вам будет гораздо проще его использовать. Пока вы изучаете Git, попробуйте забыть всё, что вы знаете о других СКВ, таких как Subversion и Perforce. Это позволит вам избежать определённых проблем при использовании инструмента. Git хранит и использует информацию совсем иначе по сравнению с другими системами, даже несмотря на то, что интерфейс пользователя достаточно похож, и понимание этих различий поможет вам избежать путаницы во время использования.

### Снимки, а не различия

Основное отличие Git от любой другой СКВ (включая Subversion и её собратьев) — это подход к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы (CVS, Subversion, Perforce, Bazaar и т. д.) представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени (обычно это называют контролем версий, _основанным на различиях_).

![Хранение данных как набора изменений относительно первоначальной версии каждого из файлов](https://git-scm.com/book/en/v2/images/deltas.png)

Рисунок 4. Хранение данных как набора изменений относительно первоначальной версии каждого из файлов

Git не хранит и не обрабатывает данные таким способом. Вместо этого, подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, **поток снимков**.

![Хранение данных как снимков проекта во времени](https://git-scm.com/book/en/v2/images/snapshots.png)

Рисунок 5. Хранение данных как снимков проекта во времени

Это очень важное отличие между Git и почти любой другой СКВ. Git переосмысливает практически все аспекты контроля версий, которые были скопированы из предыдущего поколения большинством других систем. Это делает Git больше похожим на миниатюрную файловую систему с удивительно мощными утилитами, надстроенными над ней, нежели просто на СКВ. Когда мы будем рассматривать управление ветками в главе [Ветвление в Git](https://git-scm.com/book/ru/v2/ch00/ch03-git-branching), мы увидим, какие преимущества вносит такой подход к работе с данными в Git.

### Почти все операции выполняются локально

Для работы большинства операций в Git достаточно локальных файлов и ресурсов — в основном, системе не нужна никакая информация с других компьютеров в вашей сети. Если вы привыкли к ЦСКВ, где большинство операций страдают от задержек из-за работы с сетью, то этот аспект Git заставит вас думать, что боги скорости наделили Git несказанной мощью. Так как вся история проекта хранится прямо на вашем локальном диске, большинство операций кажутся чуть ли не мгновенными.

Для примера, чтобы посмотреть историю проекта, Git не нужно соединяться с сервером для её получения и отображения — система просто считывает данные напрямую из локальной базы данных. Это означает, что вы увидите историю проекта практически моментально. Если вам необходимо посмотреть изменения, сделанные между текущей версией файла и версией, созданной месяц назад, Git может найти файл месячной давности и локально вычислить изменения, вместо того, чтобы запрашивать удалённый сервер выполнить эту операцию, либо вместо получения старой версии файла с сервера и выполнения операции локально.

Это также означает, что есть лишь небольшое количество действий, которые вы не сможете выполнить, если вы находитесь оффлайн или не имеете доступа к VPN в данный момент. Если вы в самолёте или в поезде и хотите немного поработать, вы сможете создавать коммиты без каких-либо проблем (в вашу _локальную_ копию, помните?): когда будет возможность подключиться к сети, все изменения можно будет синхронизировать. Если вы ушли домой и не можете подключиться через VPN, вы всё равно сможете работать. Добиться такого же поведения во многих других системах либо очень сложно, либо вовсе невозможно. В Perforce, для примера, если вы не подключены к серверу, вам не удастся сделать многого; в Subversion и CVS вы можете редактировать файлы, но вы не сможете сохранить изменения в базу данных (потому что вы не подключены к БД). Всё это может показаться не таким уж и значимым, но вы удивитесь, какое большое значение это может иметь.

### Целостность Git

В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение. В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии. Вы не потеряете информацию во время её передачи и не получите повреждённый файл без ведома Git.

Механизм, которым пользуется Git при вычислении хеш-сумм, называется SHA-1 хеш. Это строка длиной в 40 шестнадцатеричных символов (0-9 и a-f), она вычисляется на основе содержимого файла или структуры каталога. SHA-1 хеш выглядит примерно так:

```
24b9da6552252987aa493b52f8696cd6d3b00373
```

Вы будете постоянно встречать хеши в Git, потому что он использует их повсеместно. На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.

### Git обычно только добавляет данные

Когда вы производите какие-либо действия в Git, практически все из них только _добавляют_ новые данные в базу Git. Очень сложно заставить систему удалить данные либо сделать что-то, что нельзя впоследствии отменить. Как и в любой другой СКВ, вы можете потерять или испортить свои изменения, пока они не зафиксированы, но после того, как вы зафиксируете снимок в Git, будет очень сложно что-либо потерять, особенно, если вы регулярно синхронизируете свою базу с другим репозиторием.

Всё это превращает использование Git в одно удовольствие, потому что мы знаем, что можем экспериментировать, не боясь серьёзных проблем. Для более глубокого понимания того, как Git хранит свои данные и как вы можете восстановить данные, которые кажутся утерянными, см. [Операции отмены](https://git-scm.com/book/ru/v2/ch00/r_undoing).

### Три состояния

Теперь слушайте внимательно. Это самая важная вещь, которую нужно запомнить о Git, если вы хотите, чтобы остаток процесса обучения прошёл гладко. У Git есть три основных состояния, в которых могут находиться ваши файлы: _изменён_ (modified), _индексирован_ (staged) и _зафиксирован_ (committed):

-   К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
    
-   Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
    
-   Зафиксированный значит, что файл уже сохранён в вашей локальной базе.
    

Мы подошли к трём основным секциям проекта Git: рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory).

![Рабочая копия, область индексирования и каталог Git](https://git-scm.com/book/en/v2/images/areas.png)

Рисунок 6. Рабочая копия, область индексирования и каталог Git

Рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

Область индексирования — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

Каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при _клонировании_ репозитория с другого компьютера.

Базовый подход в работе с Git выглядит так:

1.  Изменяете файлы вашей рабочей копии.
    
2.  Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки _только_ этих изменений в индекс.
    
3.  Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.
    

Если определённая версия файла есть в каталоге Git, эта версия считается _зафиксированной_ (committed). Если файл был изменён и добавлен в индекс, значит, он _индексирован_ (staged). И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается _изменённым_ (modified). В главе [Основы Git](https://git-scm.com/book/ru/v2/ch00/ch02-git-basics-chapter) вы узнаете больше об этих состояниях и какую пользу вы можете извлечь из них или как полностью пропустить часть с индексом.

## Основы GIT

Всего несколько команд нужно для базового варианта использования Git для ведения истории изменений.

### git add

Команда `git add` добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коммита.

Это одна из ключевых команд Git, мы упоминали о ней десятки раз на страницах книги. Ниже перечислены наиболее интересные варианты использования этой команды.

Знакомство с этой командой происходит в разделе [Отслеживание новых файлов](https://git-scm.com/book/ru/v2/ch00/r_tracking_files) главы 2.

О том как использовать `git add` для разрешения конфликтов слияния написано в разделе [Основные конфликты слияния](https://git-scm.com/book/ru/v2/ch00/r_basic_merge_conflicts) главы 3.

В разделе [Интерактивное индексирование](https://git-scm.com/book/ru/v2/ch00/r_interactive_staging) главы 7 показано как использовать `git add` для добавления в индекс лишь отдельных частей изменённого файла.

В разделе [Деревья](https://git-scm.com/book/ru/v2/ch00/r_tree_objects) показано как эта команда работает на низком уровне, чтобы вы понимали, что происходит за кулисами.

### git status

Команда `git status` показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

Мы познакомили вас с этой командой в разделе [Определение состояния файлов](https://git-scm.com/book/ru/v2/ch00/r_checking_status) главы 2, разобрали стандартный и упрощённый формат вывода. И хотя мы использовали `git status` повсеместно в этой книге, практически все варианты использования покрыты в указанной главе.

### git diff

Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно `git diff`), разница между индексом и последним коммитом (`git diff --staged`), или между любыми двумя коммитами (`git diff master branchB`).

Мы познакомили вас с основами этой команды в разделе [Просмотр индексированных и неиндексированных изменений](https://git-scm.com/book/ru/v2/ch00/r_git_diff_staged) главы 2, где показали как посмотреть какие изменения уже добавлены в индекс, а какие — ещё нет.

О том как использовать эту команду для проверки на проблемы с пробелами с помощью аргумента `--check` можно почитать в разделе [Правила создания коммитов](https://git-scm.com/book/ru/v2/ch00/r_commit_guidelines) главы 5.

Мы показали вам как эффективно сравнивать ветки используя синтаксис `git diff A…​B` в разделе [Определение применяемых изменений](https://git-scm.com/book/ru/v2/ch00/r_what_is_introduced) главы 5.

В разделе [Продвинутое слияние](https://git-scm.com/book/ru/v2/ch00/r_advanced_merging) главы 7 показано использование опции `-w` для скрытия различий в пробельных символах, а также рассказано как сравнивать конфликтующие изменения с опциями `--theirs`, `--ours` и `--base`.

Использование этой команды с опцией `--submodule` для сравнения изменений в подмодулях показано в разделе [Начало работы с подмодулями](https://git-scm.com/book/ru/v2/ch00/r_starting_submodules) главы 7.

### git difftool

Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

Мы лишь вкратце упомянули о ней в разделе [Просмотр индексированных и неиндексированных изменений](https://git-scm.com/book/ru/v2/ch00/r_git_diff_staged) главы 2.

### git commit

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Вы познакомились с основами модели коммитов в разделе [Коммит изменений](https://git-scm.com/book/ru/v2/ch00/r_committing_changes) главы 2. Там же мы продемонстрировали использование опций `-a` для добавления всех изменений в индекс без использования `git add`, что может быть удобным в повседневном использовании, и `-m` для передачи сообщения коммита без запуска полноценного редактора.

В разделе [Операции отмены](https://git-scm.com/book/ru/v2/ch00/r_undoing) главы 2 мы рассказали об опции `--amend`, используемой для изменения последнего совершённого коммита.

В разделе [О ветвлении в двух словах](https://git-scm.com/book/ru/v2/ch00/r_git_branches_overview) главы 3 мы более подробно познакомились с тем, что делает команда `git commit` и почему она делает это именно так.

Мы показали вам как подписывать ваши коммиты, используя опцию `-S` в разделе [Подпись коммитов](https://git-scm.com/book/ru/v2/ch00/r_signing_commits) главы 7.

И наконец мы заглянули внутрь команды `git commit` в разделе [Объекты коммитов](https://git-scm.com/book/ru/v2/ch00/r_git_commit_objects) главы 10 и узнали что она делает за кулисами.

### git reset

Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель `HEAD` и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочем каталоге при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

Мы рассказали об основах использования `git reset` в разделе [Отмена индексации файла](https://git-scm.com/book/ru/v2/ch00/r_unstaging) главы 2, где эта команда использовалась для удаления файла из индекса, добавленного туда с помощью `git add`.

В разделе [Раскрытие тайн reset](https://git-scm.com/book/ru/v2/ch00/r_git_reset), полностью посвящённой этой команде, мы разобрались в деталях её использования.

Мы использовали `git reset --hard` чтобы отменить слияние в разделе [Прерывание слияния](https://git-scm.com/book/ru/v2/ch00/r_abort_merge) главы 7, там же было продемонстрировано использование команды `git merge --abort` для этих целей, которая работает как обёртка над `git reset`.

### git rm

Команда `git rm` используется в Git для удаления файлов из индекса и рабочей копии. Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

Мы немного разобрались с этой командой в разделе [Удаление файлов](https://git-scm.com/book/ru/v2/ch00/r_removing_files) главы 2, показали как удалять файлы из рабочего каталога и индекса и только из индекса, используя флаг `--cached`.

Ещё один вариант использования `git rm` приведён в разделе [Удаление объектов](https://git-scm.com/book/ru/v2/ch00/r_removing_objects) главы 10, где мы вкратце объяснили как использовать опцию `--ignore-unmatch` при выполнении `git filter-branch`, которая подавляет ошибки удаления несуществующих файлов. Это может быть полезно для автоматически выполняемых скриптов.

### git mv

Команда `git mv` — это всего лишь удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` для старого.

Мы лишь вкратце упомянули эту команду в разделе [Перемещение файлов](https://git-scm.com/book/ru/v2/ch00/r_git_mv) главы 2.

### git clean

Команда `git clean` используется для удаления мусора из рабочего каталога. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

Мы рассмотрели множество опций и сценариев использования этой команды в разделе [Очистка рабочего каталога](https://git-scm.com/book/ru/v2/ch00/r_git_clean) главы 7.

## Ветвление и слияния

За создание новых веток и слияние их воедино отвечает несколько Git команд.

### git branch

Команда `git branch` — это своего рода "менеджер веток". Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

Большая часть главы [Ветвление в Git](https://git-scm.com/book/ru/v2/ch00/ch03-git-branching) посвящена этой команде, она используется повсеместно в этой главе. Впервые команда `branch` была представлена в разделе [Создание новой ветки](https://git-scm.com/book/ru/v2/ch00/r_create_new_branch) главы 3, а большинство таких её возможностей как перечисление и удаление веток были разобраны в разделе [Управление ветками](https://git-scm.com/book/ru/v2/ch00/r_branch_management) главы 3.

В разделе [Отслеживание веток](https://git-scm.com/book/ru/v2/ch00/r_tracking_branches) главы 3 мы показали как использовать сочетание `git branch -u` для отслеживания веток.

Наконец, мы разобрались что происходит за кулисами этой команды в разделе [Ссылки в Git](https://git-scm.com/book/ru/v2/ch00/r_git_refs) главы 10.

### git checkout

Команда `git checkout` используется для переключения веток и выгрузки их содержимого в рабочий каталог.

Мы познакомились с этой командой в разделе [Переключение веток](https://git-scm.com/book/ru/v2/ch00/r_switching_branches) главы 3 вместе с `git branch`.

В разделе [Отслеживание веток](https://git-scm.com/book/ru/v2/ch00/r_tracking_branches) главы 3 мы узнали как использовать флаг `--track` для отслеживания веток.

В разделе [Использование команды `checkout` в конфликтах](https://git-scm.com/book/ru/v2/ch00/r_checking_out_conflicts) главы 7 мы использовали эту команду с опцией `--conflict=diff3` для разрешения конфликтов заново, в случае если предыдущее решение не подходило по некоторым причинам.

Мы рассмотрели детали взаимосвязи этой команды и `git reset` в разделе [Раскрытие тайн reset](https://git-scm.com/book/ru/v2/ch00/r_git_reset) главы 7.

Мы исследовали внутренние механизмы этой команды в разделе [HEAD](https://git-scm.com/book/ru/v2/ch00/r_the_head) главы 10.

### git merge

Команда `git merge` используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

Мы познакомили вас с этой командой в разделе [Основы ветвления](https://git-scm.com/book/ru/v2/ch00/r_basic_branching) главы 3. И хотя `git merge` встречается в этой книге повсеместно, практически все использования имеют вид `git merge <branch>` с указанием единственной ветки для слияния.

Мы узнали как делать «сплющенные» слияния (когда Git делает слияние в виде нового коммита, без сохранения всей истории работы) в конце раздела [Форк публичного проекта](https://git-scm.com/book/ru/v2/ch00/r_public_project).

В разделе [Продвинутое слияние](https://git-scm.com/book/ru/v2/ch00/r_advanced_merging) главы 7 мы глубже разобрались с процессом слияния и этой командой, включая флаги `-Xignore-all-whitespace` и `--abort`, используемый для отмены слияния в случае возникновения проблем.

Мы научились проверять криптографические подписи перед слияниями если ваш проект использует GPG в разделе [Подпись коммитов](https://git-scm.com/book/ru/v2/ch00/r_signing_commits) главы 7.

Ну и наконец в разделе [Слияние поддеревьев](https://git-scm.com/book/ru/v2/ch00/r_subtree_merge) главы 7 мы познакомились со слиянием поддеревьев.

### git mergetool

Команда `git mergetool` просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

Мы вкратце упомянули о ней в разделе [Основные конфликты слияния](https://git-scm.com/book/ru/v2/ch00/r_basic_merge_conflicts) главы 3 и рассказали как настроить свою программу слияния в разделе [Внешние программы слияния и сравнения](https://git-scm.com/book/ru/v2/ch00/r_external_merge_tools) главы 8.

### git log

Команда `git log` используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

Практически во всех главах книги эта команда используется для демонстрации истории проекта.

Мы познакомились c `git log` и некоторыми её деталями в разделе [Просмотр истории коммитов](https://git-scm.com/book/ru/v2/ch00/r_viewing_history) главы 2. Там мы видели использование опций `-p` и `--stat` для получения представления об изменениях в каждом коммите, а также `--pretty` and `--oneline` для настройки формата вывода этой команды — более полным и подробным или кратким.

В разделе [Создание новой ветки](https://git-scm.com/book/ru/v2/ch00/r_create_new_branch) главы 3 мы использовали опцию `--decorate` чтобы отобразить указатели веток на истории коммитов, а также `--graph` чтобы просматривать историю в виде дерева.

В разделах [Небольшая команда](https://git-scm.com/book/ru/v2/ch00/r_private_team) главы 5 и [Диапазоны коммитов](https://git-scm.com/book/ru/v2/ch00/r_commit_ranges) главы 7 мы познакомили вас с синтаксисом `branchA..branchB`, позволяющем команде `git log` показывать только коммиты, присутствующие в одной ветке, но отсутствующие в другой. Мы довольно подробно рассматриваем этот вопрос в разделе [Диапазоны коммитов](https://git-scm.com/book/ru/v2/ch00/r_commit_ranges).

В разделах [История при слиянии](https://git-scm.com/book/ru/v2/ch00/r_merge_log) и [Три точки](https://git-scm.com/book/ru/v2/ch00/r_triple_dot) главы 7 мы рассмотрели синтаксис `branchA…​branchB` и опцию `--left-right` позволяющие увидеть, что находится в одной или в другой ветке, но не в них обеих сразу. Также в разделе [История при слиянии](https://git-scm.com/book/ru/v2/ch00/r_merge_log) мы рассмотрели опцию `--merge`, которая может быть полезной при разрешении конфликтов, а также `--cc` для просмотра конфликтов слияния в истории проекта.

В разделе [RefLog-сокращения](https://git-scm.com/book/ru/v2/ch00/r_git_reflog) главы 7 мы использовали опцию `-g` для вывода `git reflog`, используя `git log`.

В разделе [Поиск](https://git-scm.com/book/ru/v2/ch00/r_searching) главы 7 мы рассмотрели использование опций `-S` и `-L` для поиска событий в истории проекта, например, истории развития какой-либо фичи.

В разделе [Подпись коммитов](https://git-scm.com/book/ru/v2/ch00/r_signing_commits) главы 7 мы показали, как использовать опцию `--show-signature` для отображения строки валидации подписи для каждого коммита в `git log`.

### git stash

Команда `git stash` используется для временного сохранения всех незафиксированных изменений с целью очистки рабочего каталога без необходимости фиксировать незавершённую работу в текущей ветке.

Эта команда практически целиком раскрыта в разделе [Припрятывание и очистка](https://git-scm.com/book/ru/v2/ch00/r_git_stashing) главы 7.

### git tag

Команда `git tag` используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

Мы познакомились и разобрались с ней в разделе [Работа с тегами](https://git-scm.com/book/ru/v2/ch00/r_git_tagging) главы 2 и использовали на практике в разделе [Помечайте свои релизы](https://git-scm.com/book/ru/v2/ch00/r_tagging_releases) главы 5.

Мы научились создавать подписанные с помощью GPG метки, используя флаг `-s`, и проверять их, используя флаг `-v`, в разделе [Подпись](https://git-scm.com/book/ru/v2/ch00/r_signing) главы 7.
## Совместная работа и обновление проектов

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

### git fetch

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Мы познакомились с ней в разделе [Получение изменений из удалённого репозитория — Fetch и Pull](https://git-scm.com/book/ru/v2/ch00/r_fetching_and_pulling) главы 2 и продолжили знакомство в разделе [Удалённые ветки](https://git-scm.com/book/ru/v2/ch00/r_remote_branches) главы 3.

Мы использовали эту команду в нескольких примерах из раздела [Участие в проекте](https://git-scm.com/book/ru/v2/ch00/r_contributing_project).

Мы использовали её для скачивания запросов на слияние (pull request) из других репозиториев в разделе [Ссылки на запрос слияния](https://git-scm.com/book/ru/v2/ch00/r_pr_refs) главы 6, также мы рассмотрели использование `git fetch` для работы с упакованными репозиториями в разделе [Создание пакетов](https://git-scm.com/book/ru/v2/ch00/r_bundling) главы 7.

Мы рассмотрели тонкую настройку `git fetch` в главе и [Спецификации ссылок](https://git-scm.com/book/ru/v2/ch00/r_refspec).

### git pull

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

Мы познакомились с ней в разделе [Получение изменений из удалённого репозитория — Fetch и Pull](https://git-scm.com/book/ru/v2/ch00/r_fetching_and_pulling) главы 2 и показали как узнать, какие изменения будут приняты в случае применения в разделе [Просмотр удаленного репозитория](https://git-scm.com/book/ru/v2/ch00/r_inspecting_remote) главы 2.

Мы также увидели как она может оказаться полезной для разрешения сложностей при перемещении веток в разделе [Меняя базу, меняй основание](https://git-scm.com/book/ru/v2/ch00/r_rebase_rebase) главы 3.

Мы показали как можно использовать только URL удалённого репозитория без сохранения его в списке удалённых репозиториев в разделе [Извлечение удалённых веток](https://git-scm.com/book/ru/v2/ch00/r_checking_out_remotes) главы 5.

И наконец мы показали как проверять криптографические подписи полученных коммитов, используя опцию `--verify-signatures` в разделе [Подпись коммитов](https://git-scm.com/book/ru/v2/ch00/r_signing_commits) главы 7.

### git push

Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

Мы познакомились с этой командой в разделе [Отправка изменений в удаленный репозиторий (Push)](https://git-scm.com/book/ru/v2/ch00/r_pushing_remotes) главы 2. Там мы рассмотрели основы обновления веток в удалённом репозитории. В разделе [Отправка изменений](https://git-scm.com/book/ru/v2/ch00/r_pushing_branches) главы 3 мы подробнее познакомились с этой командой, а в разделе [Отслеживание веток](https://git-scm.com/book/ru/v2/ch00/r_tracking_branches) главы 3 мы узнали как настроить отслеживание веток для автоматической передачи на удалённый репозиторий. В разделе [Удаление веток на удалённом сервере](https://git-scm.com/book/ru/v2/ch00/r_delete_branches) главы 3 мы использовали флаг `--delete` для удаления веток на сервере, используя `git push`.

На протяжении раздела [Участие в проекте](https://git-scm.com/book/ru/v2/ch00/r_contributing_project) мы показали несколько примеров использования `git push` для совместной работы в нескольких удалённых репозиториях одновременно.

В разделе [Публикация изменений подмодуля](https://git-scm.com/book/ru/v2/ch00/r_publishing_submodules) главы 7 мы использовали опцию `--recurse-submodules` чтобы удостовериться, что все подмодули будут опубликованы перед отправкой проекта на сервер, что может быть реально полезным при работе с репозиториями, содержащими подмодули.

В разделе [Прочие хуки на стороне клиента](https://git-scm.com/book/ru/v2/ch00/r_other_client_hooks) главы 8 мы поговорили о триггере `pre-push`, который может быть выполнен перед отправкой данных, чтобы проверить возможность этой отправки.

Наконец, в разделе [Спецификации ссылок для отправки данных на сервер](https://git-scm.com/book/ru/v2/ch00/r_pushing_refspecs) главы 10 мы рассмотрели передачу данных с полным указанием передаваемых ссылок, вместо использования распространённых сокращений. Это может быть полезным если вы хотите очень точно указать, какими изменениями хотите поделиться.

### git remote

Команда `git remote` служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например «origin», так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и `git remote` поможет добавлять, изменять и удалять их.

Эта команда детально рассмотрена в разделе [Работа с удалёнными репозиториями](https://git-scm.com/book/ru/v2/ch00/r_remote_repos) главы 2, включая вывод списка удалённых репозиториев, добавление новых, удаление или переименование существующих.

Она используется практически в каждой главе, но всегда в одном и том же виде: `git remote add <имя> <URL>`.

### git archive

Команда `git archive` используется для упаковки в архив указанных коммитов или всего репозитория.

Мы использовали `git archive` для создания тарбола (`tar.gz` файла) всего проекта для передачи по сети в разделе [Подготовка релиза](https://git-scm.com/book/ru/v2/ch00/r_preparing_release) главы 5.

### git submodule

Команда `git submodule` используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды `submodule` есть несколько под-команд — `add`, `update`, `sync` и др. — для управления такими репозиториями.
## Осмотр и сравнение

### git show

Команда `git show` отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

Впервые мы использовали её для просмотра информации об аннотированной метке в разделе [Аннотированные теги](https://git-scm.com/book/ru/v2/ch00/r_annotated_tags) главы 2.

В разделе [Выбор ревизии](https://git-scm.com/book/ru/v2/ch00/r_revision_selection) главы 7 мы использовали её для показа коммитов, подпадающих под различные селекторы диапазонов.

Ещё одна интересная вещь, которую мы проделывали с помощью `git show` в разделе [Ручное слияние файлов](https://git-scm.com/book/ru/v2/ch00/r_manual_remerge) главы 7 — это извлечение содержимого файлов на различных стадиях во время конфликта слияния.

### git shortlog

Команда `git shortlog` служит для подведения итогов команды `git log`. Она принимает практически те же параметры, что и `git log`, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

Мы показали, как можно использовать эту команду для создания классных списков изменений (changelogs) в разделе [Краткая история (Shortlog)](https://git-scm.com/book/ru/v2/ch00/r_the_shortlog) главы 5.

### git describe

Команда `git describe` принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

Мы использовали `git describe` в главах [Генерация номера сборки](https://git-scm.com/book/ru/v2/ch00/r_build_number) и [Подготовка релиза](https://git-scm.com/book/ru/v2/ch00/r_preparing_release) чтобы сгенерировать название для архивного файла с релизом.
## Отладка

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

### git bisect

Команда `git bisect` — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

О ней упоминается только в разделе [Бинарный поиск](https://git-scm.com/book/ru/v2/ch00/r_binary_search) главы 7, где она полностью и раскрыта.

### git blame

Команда `git blame` выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

Эта команда полностью разобрана в разделе [Аннотация файла](https://git-scm.com/book/ru/v2/ch00/r_file_annotation) главы 7.

### git grep

Команда `git grep` используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.
## Внесение исправлений

Некоторые команды в Git основываются на подходе к рассмотрению коммитов в терминах внесённых ими изменений, т. е. рассматривают историю коммитов как цепочку патчей. Ниже перечислены эти команды.

### git cherry-pick

Команда `git cherry-pick` берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

Этот процесс описан и показан в разделе [Схема с перебазированием и отбором](https://git-scm.com/book/ru/v2/ch00/r_rebase_cherry_pick) главы 5.

### git rebase

`git rebase` — это «автоматизированный» `cherry-pick`. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

Мы в деталях разобрались с механизмом переноса веток в разделе [Перебазирование](https://git-scm.com/book/ru/v2/ch00/r_rebasing) главы 3, включая рассмотрение потенциальных проблем переноса опубликованных веток при совместной работе.

Мы использовали эту команду на практике для разбиения истории на два репозитория в разделе [Замена](https://git-scm.com/book/ru/v2/ch00/r_replace) главы 7, наряду с использованием флага `--onto`.

В разделе [Rerere](https://git-scm.com/book/ru/v2/ch00/r_rerere) главы 7 мы рассмотрели случай возникновения конфликта во время переноса коммитов.

Также мы познакомились с интерактивным вариантом `git rebase`, включающемся с помощью опции `-i`, в разделе [Изменение сообщений нескольких коммитов](https://git-scm.com/book/ru/v2/ch00/r_changing_multiple) главы 7.

### git revert

Команда `git revert` — полная противоположность `git cherry-pick`. Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.

Мы использовали её в разделе [Отмена коммита](https://git-scm.com/book/ru/v2/ch00/r_reverse_commit) главы 7 чтобы отменить коммит слияния (merge commit).

## Git-flow

Git-flow — альтернативная модель ветвления Git, в которой используются функциональные ветки и несколько основных веток. Эта модель была впервые опубликована и популяризована [Винсентом Дриссеном на сайте nvie](http://nvie.com/posts/a-successful-git-branching-model/). По сравнению с моделью магистральной разработки, в Git-flow используется больше веток, каждая из которых существует дольше, а коммиты обычно крупнее. В соответствии с этой моделью разработчики создают функциональную ветку и откладывают ее слияние с главной магистральной веткой до завершения работы над функцией. Такие долгосрочные функциональные ветки требуют тесного взаимодействия разработчиков при слиянии и создают повышенный риск отклонения от магистральной ветки. В них также могут присутствовать конфликтующие обновления.

Git-flow можно использовать для проектов, в которых запланирован цикл релизов и реализуется характерная для [DevOps](https://www.atlassian.com/ru/devops/what-is-devops/devops-best-practices) методика [непрерывной поставки](https://www.atlassian.com/ru/continuous-delivery). В этом рабочем процессе используются понятия и команды, которые были предложены в рамках [рабочего процесса с функциональными ветками](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/feature-branch-workflow). Однако Git-flow привносит новые специфические роли для разных веток и определяет характер и частоту взаимодействия между ними. Помимо функциональных веток в рамках этого рабочего процесса используются отдельные ветки для подготовки, поддержки и регистрации релизов. При этом вы по-прежнему можете пользоваться преимуществами рабочего процесса с функциональными ветками, такими как запросы pull, изолированные эксперименты и эффективное командное взаимодействие.


## **SVN vs Git: What is the Difference Between Git and SVN?**

While Git and SVN are both enterprise version control systems (VCS) that help with workflow and project management in coding, they do have their differences. The difference between Git and SVN version control systems is that Git is a distributed version control system, whereas SVN is a centralized version control system. Git uses multiple repositories including a centralized repository and server, as well as some local repositories. SVN does not have a centralized repository or server.

### **What is GIT?**

![](https://hackbrightacademy.com/content/uploads/2013/08/git_all_the_things.png)**Git is a distributed version control system** – which just means that when you do a **git clone (+url of your repository)** what you are actually getting is a complete copy of your entire history of that project. This means all your commits! Woot!

### **What are the advantages of Git?**

Git has a staging area. This just means that if you made 100 new changes to your code, you can break these 100 changes into 10 or 20 or more commits each with their own comments and their own detailed explanation of what just happened! Not only can you stage your commits out to logically display what changes were made, but you can also do patch staging that ask you if you want. You would use patch staging if you and a co-worker are both working on the same file and you only want to commit a particular function that you’ve worked on. You do a Git patch using “git add -p”

**Git Work Flow**

![](https://hackbrightacademy.com/content/uploads/2013/08/git_work_flow.png)

### **What is SVN?**

Subversion (SVN) may be one of the most well known centralized version control systems. In Subversion or SVN, you are checking out a single version of the repository. With SVN, your data is stored on a central server. Having the entire history on your local repository just means that even when you are not connected to the Internet, you can still do commits, diffs, logs, branches, merges, file annotations, etc.

### **What are the advantages of SVN?**

SVN has one central repository – which makes it easier for managers to have more of a top down approach to control, security, permissions, mirrors and dumps. Additionally, many say SVN is easier to use than Git. For example, it is easier to create a new feature. With Git, it takes an extra step to create a new feature. Others say that the way SVN is set up results in greater trunk stability, and having everything on a central server feels more controlled and secure for some.

**SVN Work Flow**

![](https://hackbrightacademy.com/content/uploads/2013/08/svn_work_flow.png)

### **SVN vs Git**

**SVN allows you to check out **sub-trees** (or branches) only whereas Git requires you to check out the entire repository as a unit.** This is because there is a .svn in each one of your folders while git only has one .git at the top level parent directory.

### **Is Git better than SVN?**

Git and SVN are each viable workflow and version control systems, but for different reasons. Git may have more difficulty compressing and storing binary files, while SVN doesn’t as much. That said, many claim Git is better than SVN because it works well even for developers who aren’t always connected to the master repository, as it is available offline. Branching and merging support are also thought to be superior with Git. When it comes to disk space storage, it’s pretty close to equal between both SVN and Git repositories. Git is also a bit newer than SVN.

### **SVN vs Git: It’s up to you**

I’m sure there are a lot more ways that GIT and SVN differ. If you take time to look for an example or two of how one or the other is best suited to your enterprise or workflow, you may have an easier time talking to management about getting the right VCS for your needs.