## Что такое тесты?
**Тест** (от [англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") test «испытание, проверка») или **испытание** — способ изучения глубинных процессов деятельности системы, посредством помещения системы в разные ситуации и отслеживание доступных наблюдению изменений в ней.


## Зачем они нужны?

Проблема в том, что разработчики не могут писать код без ошибок.  
Более того, в сколько-нибудь сложных программных системах при внесении каких-либо изменений слишком сложно понять, как это отразится на других частях.  
Для того, что бы минимизировать поиски этих багов и ускорить их обнаружение пишутся юнит тесты.  
  
ТДД про то, что бы писать тесты до кода.  
Зачем это надо? Потому что такой подход помогает лучше структурировать в голове необходимую функциональность перед написанием непосредственно кода.  
Такой подход позволяет избегать избыточного усложнения кода, потому что подход "tests first" не позволяет написать полотнище сложного кода, не проверив правильность его работы.  
Плюсов достаточно.  
  
Теперь по поводу того, нужно ли ТДД всегда.  
ТДД нужно не всегда, как и красивый, производительный и правильно работающий код.  
Иногда, нужно закостылить MVP, проверить бизнес-идею и продолжить жить. В таком подходе 20% времени, потраченные на юниты - непозволительная роскошь.  
Иногда, вы пишете систему, сложность которой такова, что держать в голове матрицу состояний даже одного модуля не представляется возможным. И тут уже без юнит-тестов никак. Тут ТДД будет полезно.  
  
Резюмируя. ТДД - отличный инструмент. Он позволяет не откладывать на потом написание юнит тестов, добиваться хорошего покрытия и, что важнее всего, контролировать изменения, вносимые в систему. Любая неожиданная ветка поведения приведет к падению тестов.  
Как и любой инструмент - ТДД хорошо тогда, когда ты применяешь его своевременно, правильно и по назначению.  
Писать тесты когда продакшен в огне, а компания терпит крах - плохая идея. Везде нужен здравый смысл.


## Что такое Unit тесты?

Основной смысл модульного тестирования заключается в том, чтобы избежать накапливания ошибок в будущем, а также исключить регрессию уже отлаженных модулей. Например, у вас есть в целом готовое приложение, к которому необходимо добавить несколько новых функций или процессов. Если сначала выполнить интеграцию компонентов, а потом протестировать полностью «собранное» ПО, то ошибки в дополнениях могут привести к нестабильной работе всего приложения. Чтобы этого не произошло, легче протестировать добавляемые функции изолированно, а после устранения всех багов интегрировать их в программу.

Таким образом, unit-тестирование решает следующие задачи:

-   поиск и исправление ошибок на ранних стадиях разработки программного продукта и, следовательно, снижение затрат в дальнейшем;
-   лучшее понимание разработчиками базового кода проекта, более простая и быстрая корректировка продукта;
-   повторное использование кода, в том числе с переносом (вместе с тестами) в другие продукты;
-   использование юнит-тестов как проектной документации, по которой разработчики, не знакомые с кодом, могут понять принцип его работы.

![](https://blog.skillfactory.ru/wp-content/uploads/2022/05/unit-1-2084424.png)

Unit-тесты в иерархии всех видов тестирования ПО

### Преимущества unit-тестирования

Применять модульное тестирование при разработке программных продуктов рекомендуется по следующим причинам:

-   **Простота.** Написать тест для отдельного модуля проще, чем для приложения в целом. Соответственно, если нужно проверить не всю программу, а лишь ее часть (например, вышедшее обновление или патч), то можно использовать модульное тестирование, предварительно изолировав проверяемый фрагмент кода. Хотя интеграционное тестирование нужно будет провести в любом случае.
-   **Информативность.** Хорошо составленный тест помогает разработчикам понять API приложения, функционал модуля, особенности его использования. Особенно это полезно в том случае, если при работе над проектом произошла смена ответственных за разработку и проверку специалистов.
-   **Параллельная разработка.** Модульное тестирование позволяет проверить работу одного компонента приложения независимо от других. Благодаря этому можно параллельно разрабатывать различные программные модули, тем самым сократив время на создание и отладку продукта.
-   **Возможность повторного использования.** Создав однажды тест для проверки отдельного модуля, разработчик может вернуться к нему позднее, чтобы протестировать работу компонента еще раз. Регрессионное тестирование состоит в написании контрольных примеров для всех функций, которые помогают выявить ошибки, вызванные внесенными изменениями.

### Недостатки unit-тестирования

Несмотря на свои достоинства, модульное тестирование не является панацеей от всех болезней кода:

-   Модульное тестирование не гарантирует, что будут найдены все ошибки. Причина в том, что даже в относительно простых программах невозможно предугадать все сценарии их выполнения.
-   Unit-тестирование применяется к изолированным фрагментам кода, поэтому может выявить только ошибки проверяемого модуля. Оно не способно показать баги, возникающие при интеграции модуля с другими компонентами приложения. Также unit-тестирование не способно выявить системные ошибки продукта в целом.
- 
## Какие виды тестов существуют?

### 1. Модульные тесты

Модульные тесты работают на очень низком уровне, близко к исходному коду приложения. Они заключаются в тестировании отдельных методов и функций классов, компонентов или модулей, используемых в ПО. Модульные тесты, как правило, не требуют больших расходов на автоматизацию и могут выполняться сервером непрерывной интеграции очень быстро.

### 2. Интеграционные тесты

В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением. Например, можно протестировать взаимодействие с базой данных или убедиться, что микросервисы работают вместе так, как задумано. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения.

### 3. Функциональные тесты

В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.

Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

### 4. Сквозные тесты

Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).

Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

### 5. Приемочное тестирование

Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

### 6. Тестирование производительности

В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

### 7. Smoke-тестирование

Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.

Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).

## Что такое Mock? Отличия dummy/fake/stub/mock
Прежде чем перейти к теме того, когда использовать моки, давайте обсудим, что такое мок. Люди часто используют термины тестовый двойник (test double) и мок (mock) как синонимы, но технически это не так:

-   Тестовый двойник - это всеобъемлющий термин, который описывает все виды фальшивых (fake) зависимостей, непригодных к использованию в конечном продукте (non-production-ready), в тестах. Такая зависимость выглядит и ведет себя как ее аналог, предназначенный для production, но на самом деле является упрощенной версией, которая снижает сложность и облегчает тестирование. Этот термин был введен Джерардом Месаросом в его книге «[xUnit Test Patterns: Refactoring Test Code](https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054)». Само название происходит от понятия дублера в кино.
-   Мок – это лишь один из видов таких зависимостей.

Согласно Жерару Месарошу, существует 5 видов тестовых двойников:

-   Пустышка (dummy)
    
-   Стаб (stub)
    
-   Шпион (spy)
    
-   Мок (mock)
    
-   Фейк (fake)

Такое разнообразие может показаться пугающим, но на самом деле все они могут быть сгруппированы всего в два типа: моки и стабы.

![Рис.1 - Все варианты тестовых двойников можно разделить на два типа: моки и стабы.](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b46/2d1/3d6/b462d13d6d3b0e71bc276ce56755dffe.png "Рис.1 - Все варианты тестовых двойников можно разделить на два типа: моки и стабы.")

Рис.1 - Все варианты тестовых двойников можно разделить на два типа: моки и стабы.

Разница между этими двумя типами сводится к следующему:

-   Моки помогают имитировать и изучать **исходящие (outcoming)** взаимодействия. То есть вызовы, совершаемые тестируемой системой (SUT) к ее зависимостям для изменения их состояния.
    
-   Стабы помогают имитировать **входящие (incoming)** взаимодействия. То есть вызовы, совершаемые SUT к ее зависимостям для получения входных данных.
    

Например, отправка электронной почты является **исходящим (outcoming)** взаимодействием: это взаимодействие приводит к побочному эффекту на SMTP-сервере. Тестовый двойник, имитирующий такое взаимодействие, - это мок.

Извлечение данных из БД является **входящим (incoming)** взаимодействием — оно не приводит к побочному эффекту. Соответствующий тестовый двойник является стабом.

![Рис.2 - Моки предназначены для исходящего взаимодействия; стабы — для входящего.](https://habrastorage.org/r/w1560/getpro/habr/upload_files/555/39f/d5c/55539fd5c507bac221eb1ebf721c34f2.png "Рис.2 - Моки предназначены для исходящего взаимодействия; стабы — для входящего.")

Рис.2 - Моки предназначены для исходящего взаимодействия; стабы — для входящего.

Все остальные различия между пятью типами тестовых двойников являются незначительными деталями реализации:

-   Spies (шпионы) выполняют ту же роль, что и моки. Отличие в том, что spies пишутся вручную, а моки создаются с помощью готовых инструментов. Иногда spies называют рукописными моками.
    

С другой стороны, разница между стабами, dummy (пустышками) и фейками заключается в том, насколько они умны:

-   Dummy - это простое, жестко закодированное значение, такое как _null_ значение или выдуманная строка. Он используется для удовлетворения сигнатуры метода SUT и не участвует в получении конечного результата.
    
-   Стаб посложнее. Это полноценная зависимость, которую вы настраиваете для возврата разных значений для разных сценариев.
    
-   Фейк - это то же самое, что и стаб для большинства целей. Разница заключается в причинах его создания: фейк обычно используется для замены еще не существующей зависимости.
    

Обратите внимание на разницу между моками и стабами (помимо исходящих и входящих взаимодействий). Моки помогают эмулировать и изучать взаимодействия между SUT и его зависимостями, в то время как стабы помогают только эмулировать эти взаимодействия. Это важное различие.
## Пирамида тестов
![](https://blog.skillfactory.ru/wp-content/uploads/2022/05/unit-1-2084424.png)
## Интеграционное vs. Модульное

«Юнит-тестирование и интеграционное тестирование — возможно самые применяемые виды тестирования, которым подвергается современный софт.

Итак посмотрим, что собой представляют такие тесты такого типа, чем отличаются эти два типа тестирования, и с какой точки зрения они помогают делать софт лучше.

### Юнит-тестирование

Надежный софт это тот, который разработчики сами протестировали, проверяя код написанных модулей. Юнит-тестирование (называемое еще модульным), проверяет отдельные модули приложения (вплоть до отдельной функции или метода).

Чтобы лучше понять юнит-тестирование, представим исходники большого сложного приложения. Разработчики пишут код и продумывают логику приложения, и они должны дать самый первый ответ, является ли их софт функциональным, безопасным, продуктивным в достаточной мере. Итак, юнит-тест проверяет модуль «изолированно» от остального кода в проекте.

Хотя юнит-тесты обычно простые, их объем зависит от изначальной упорядоченности и «ясности» кода модуля. Легко тестируется небольшой, хорошо структурированный код, “не слишком связный” (имеется в виду — без большого количества «связей» с другими модулями). Это позволяет выловить ошибки еще на начальной стадии, а не в самом конце, когда «цена исправления ошибки» уже становится большой.

### Челленджи юнит-тестирования

Такое тестирование, в принципе, самый распространенный и самый очевидный тип тестирования (возможно самый первый из существовавших), выполняемый теми же людьми, кто писал код всех компонентов и функций. Это радикально упрощает работу. Но если юнит-тесты заставляют делать тестировщиков, то тут уже возможны «челенджи». Особенно если код писался без оглядки на юнит-тестирование.

### Плюсы юнит-тестирования

-   Модули тестируются изолированно, что дает результат в виде проверенного кода, сразу в начале пайплайна
-   Быстрая отработанная методология
-   Тестируют те, кто писал код
-   Быстрое выполнение тестов, поэтому можно тестировать много раз
-   Снижение [технического долга](https://www.wikiwand.com/ru/%D0%A2%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%BE%D0%BB%D0%B3) и стоимости обслуживания в больших проектах

### Интеграционное тестирование

В отличие от юнит-тестирования, нацеленного на (небольшие) модули, интеграционное тестирование является в некоем роде противоположностью — оно проверяет весь код и плюс его зависимости. Юниты-модули могут быть сколь угодно идеальными, а приложение в целом будет бесполезным, если весь код «в целом» не работает как положено во внешнем окружении после деплоя. Другими словами, интеграционное тестирование тестирует приложение «во всей его красе».

Интеграционные тесты выполняются QA-отделом (или QA-командой), который выполняет тест-кейсы, проверяя производительность и функциональность приложения.

Зная, что интеграционные тесты проверяют все приложение; и его зависимости; и «область контакта с внешними системами», лучше не увлекаться таким типом тестирования «слишком интенсивно». Интеграционные тесты позволяют отыскать баги, возникающие из взаимодействия модулей кода между собой, а такие баги случаются весьма часто.

### Челенджи в интеграционном тестировании

Хотя интеграционные тесты делаются чтобы проверить связность компонентов «в реальном мире» включая «выходы приложения», бывает не так просто создать “тестовое окружение как в реальном мире”. Всегда есть какие-то ограничения, потому что внешние системы часто сложны в интеграции с тестовым окружением. Хорошая новость: есть подходящие решения для тестировщиков, «приближающие» интеграционные тесты к реальному миру.

### Плюсы интеграционного тестирования

-   Проверяет «связность» всего кода и зависимостей, и как код себя ведет в продакшен-окружении
-   Находит баги как в коде приложения, так и в зависимостях
-   Высокая эффективность: проверяются интерфейсы и взаимодействия между модулями в приложении, а там часто баги

### Какие тесты нужны, юнит- или интеграционные?

Ситуации бывают разные. Теоретически надо применять оба типа, а реально все зависит от требований клиента и бизнес-целей. Обычно делается последовательно: разработчики “пропустили” свой код через юнит-тестирование, затем тестировщики занялись интеграционным тестированием, проверяя функциональность и эффективность всего приложения и его зависимостей.»
## JUnit @Ignore
The @Ignore test annotation is used to ignore particular tests or group of tests in order to skip the build failure.

**@Ignore** annotation can be used in two scenarios as given below:

1.  If you want to ignore a test method, use @Ignore along with @Test annotation.
2.  If you want to ignore all the tests of class, use @Ignore annotation at the class level.

You can provide the reason for disabling a test in the optional parameter provided by @Ignore annotation.

It will help other developers working on the same piece of code, to understand “why a particular test is disabled?” When the issue of that particular test is fixed, you can simply enable it by removing **@Ignore annotation**.
